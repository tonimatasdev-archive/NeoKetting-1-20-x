--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -190,11 +_,37 @@
     private final List<CustomSpawner> customSpawners;
     @Nullable
     private EndDragonFight dragonFight;
-    final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectOpenHashMap<>();
+    final Int2ObjectMap<net.neoforged.neoforge.entity.PartEntity<?>> dragonParts = new Int2ObjectOpenHashMap<>();
     private final StructureManager structureManager;
     private final StructureCheck structureCheck;
     private final boolean tickTime;
     private final RandomSequences randomSequences;
+    // CraftBukkit start
+    public final LevelStorageSource.LevelStorageAccess convertable;
+    public final UUID uuid;
+
+    public LevelChunk getChunkIfLoaded(int x, int z) {
+        return this.chunkSource.getChunk(x, z, false);
+    }
+
+    @Override
+    public ResourceKey<LevelStem> getTypeKey() {
+        return convertable.dimensionType;
+    }
+
+    //Ketting start - return serverleveldata
+    public net.minecraft.world.level.storage.PrimaryLevelData getServerLevelData() {
+        if (serverLevelData instanceof org.kettingpowered.ketting.utils.DelegateWorldInfo delegate) {
+            return delegate;
+        } else if (serverLevelData instanceof net.minecraft.world.level.storage.PrimaryLevelData primary) {
+            return primary;
+        } else if (serverLevelData instanceof net.minecraft.world.level.storage.DerivedLevelData derived) {
+            return org.kettingpowered.ketting.utils.DelegateWorldInfo.wrap(derived);
+        } else {
+            throw new UnsupportedOperationException("Could not wrap level data");
+        }
+    }
+    //Ketting end
 
     public ServerLevel(
         MinecraftServer p_214999_,
@@ -221,31 +_,33 @@
             p_215007_,
             p_214999_.getMaxChainedNeighborUpdates()
         );
+        this.pvpMode = p_214999_.isPvpAllowed();
+        convertable = p_215001_;
+        uuid = org.bukkit.craftbukkit.v1_20_R3.util.WorldUUID.getUUID((p_215002_ instanceof net.minecraft.world.level.storage.DerivedLevelData ? p_215001_.getDimensionPath(p_215003_) : p_215001_.levelDirectory.path()).toFile()); //Ketting
+        // CraftBukkit end
         this.tickTime = p_215009_;
         this.server = p_214999_;
         this.customSpawners = p_215008_;
-        this.serverLevelData = p_215002_;
-        ChunkGenerator chunkgenerator = p_215004_.generator();
+        //Ketting start - wrap level data
+        if (p_215002_ instanceof net.minecraft.world.level.storage.PrimaryLevelData primary) {
+            this.serverLevelData = primary;
+        } else if (p_215002_ instanceof net.minecraft.world.level.storage.DerivedLevelData derived) {
+            this.serverLevelData = org.kettingpowered.ketting.utils.DelegateWorldInfo.wrap(derived);
+        } else {
+            org.kettingpowered.ketting.core.Ketting.LOGGER.warn("Could not wrap level data, this can cause some problems with bukkit", new UnsupportedOperationException());
+            this.serverLevelData = p_215002_;
+        }
+        //Ketting end
+        ChunkGenerator chunkgenerator = bukkitInit(p_215004_.generator()); //Ketting
         boolean flag = p_214999_.forceSynchronousWrites();
         DataFixer datafixer = p_214999_.getFixerUpper();
         EntityPersistentStorage<Entity> entitypersistentstorage = new EntityStorage(
             this, p_215001_.getDimensionPath(p_215003_).resolve("entities"), datafixer, flag, p_214999_
         );
         this.entityManager = new PersistentEntitySectionManager<>(Entity.class, new ServerLevel.EntityCallbacks(), entitypersistentstorage);
-        this.chunkSource = new ServerChunkCache(
-            this,
-            p_215001_,
-            datafixer,
-            p_214999_.getStructureManager(),
-            p_215000_,
-            chunkgenerator,
-            p_214999_.getPlayerList().getViewDistance(),
-            p_214999_.getPlayerList().getSimulationDistance(),
-            flag,
-            p_215005_,
-            this.entityManager::updateChunkStatus,
-            () -> p_214999_.overworld().getDataStorage()
-        );
+        this.chunkSource = new ServerChunkCache(this, p_215001_, datafixer, p_214999_.getStructureManager(), p_215000_, chunkgenerator, this.spigotConfig.viewDistance, this.spigotConfig.simulationDistance, flag, p_215005_, this.entityManager::updateChunkStatus, () -> { // Spigot
+            return p_214999_.overworld().getDataStorage();
+        });
         this.chunkSource.getGeneratorState().ensureStructuresGenerated();
         this.portalForcer = new PortalForcer(this);
         this.updateSkyBrightness();
@@ -269,9 +_,9 @@
             i,
             datafixer
         );
-        this.structureManager = new StructureManager(this, p_214999_.getWorldData().worldGenOptions(), this.structureCheck);
+        this.structureManager = new StructureManager(this, getServerLevelData().worldGenOptions(), this.structureCheck); // CraftBukkit //Ketting - don't enforce PrimaryLevelData
         if (this.dimension() == Level.END && this.dimensionTypeRegistration().is(BuiltinDimensionTypes.END)) {
-            this.dragonFight = new EndDragonFight(this, i, p_214999_.getWorldData().endDragonFightData());
+            this.dragonFight = new EndDragonFight(this, getServerLevelData().worldGenOptions().seed(), getServerLevelData().endDragonFightData()); // CraftBukkit //Ketting - don't enforce PrimaryLevelData
         } else {
             this.dragonFight = null;
         }
@@ -281,7 +_,42 @@
         this.randomSequences = Objects.requireNonNullElseGet(
             p_288977_, () -> this.getDataStorage().computeIfAbsent(RandomSequences.factory(i), "random_sequences")
         );
-    }
+
+        net.neoforged.neoforge.attachment.LevelAttachmentsSavedData.init(this);
+    }
+
+    //Ketting start
+    public ServerLevel(MinecraftServer p_214999_, Executor p_215000_, LevelStorageSource.LevelStorageAccess p_215001_, net.minecraft.world.level.storage.PrimaryLevelData p_215002_, ResourceKey<Level> p_215003_, LevelStem p_215004_, ChunkProgressListener p_215005_, boolean p_215006_, long p_215007_, List<CustomSpawner> p_215008_, boolean p_215009_, @Nullable RandomSequences p_288977_, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider) {
+        this(p_214999_, p_215000_, p_215001_, p_215002_, p_215003_, p_215004_, p_215005_, p_215006_, p_215007_, p_215008_, p_215009_, wrap(p_288977_, env, gen, biomeProvider));
+    }
+    private static @Nullable RandomSequences wrap(@Nullable RandomSequences p_288977_, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider) {
+        init$env = env;
+        init$gen = gen;
+        init$biomeProvider = biomeProvider;
+        return p_288977_;
+    }
+    //Ketting end
+
+    private ChunkGenerator bukkitInit(ChunkGenerator chunkgenerator){
+        // CraftBukkit start
+        getServerLevelData().setWorld(this); //Ketting - don't enforce PrimaryLevelData
+
+        if (this.biomeProvider != null) {
+            net.minecraft.world.level.biome.BiomeSource worldChunkManager = new org.bukkit.craftbukkit.v1_20_R3.generator.CustomWorldChunkManager(getWorld(), biomeProvider, server.registryAccess().registryOrThrow(Registries.BIOME));
+            if (chunkgenerator instanceof net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator cga) {
+                chunkgenerator = new net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator(worldChunkManager, cga.settings);
+            } else if (chunkgenerator instanceof net.minecraft.world.level.levelgen.FlatLevelSource cpf) {
+                chunkgenerator = new net.minecraft.world.level.levelgen.FlatLevelSource(cpf.settings(), worldChunkManager);
+            }
+        }
+
+        if (this.generator != null) {
+            chunkgenerator = new org.bukkit.craftbukkit.v1_20_R3.generator.CustomChunkGenerator(this, chunkgenerator, generator);
+        }
+
+        return chunkgenerator;
+        // CraftBukkit end
+        }
 
     @Deprecated
     @VisibleForTesting
@@ -322,13 +_,22 @@
         }
 
         int i = this.getGameRules().getInt(GameRules.RULE_PLAYERS_SLEEPING_PERCENTAGE);
+        long j;
         if (this.sleepStatus.areEnoughSleeping(i) && this.sleepStatus.areEnoughDeepSleeping(i, this.players)) {
+            // CraftBukkit start
+            j = this.levelData.getDayTime() + 24000L;
+            org.bukkit.event.world.TimeSkipEvent event = new org.bukkit.event.world.TimeSkipEvent(this.getWorld(), org.bukkit.event.world.TimeSkipEvent.SkipReason.NIGHT_SKIP, (j - j % 24000L) - this.getDayTime());
             if (this.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)) {
-                long j = this.levelData.getDayTime() + 24000L;
-                this.setDayTime(j - j % 24000L);
+                this.getCraftServer().getPluginManager().callEvent(event);
+                if (!event.isCancelled()) {
+                    this.setDayTime(this.getDayTime() + event.getSkipAmount());
+                }
             }
 
-            this.wakeUpAllPlayers();
+            if (!event.isCancelled()) {
+                this.wakeUpAllPlayers();
+            }
+            // CraftBukkit end
             if (this.getGameRules().getBoolean(GameRules.RULE_WEATHER_CYCLE) && this.isRaining()) {
                 this.resetWeatherCycle();
             }
@@ -340,6 +_,7 @@
         }
 
         profilerfiller.popPush("tickPending");
+        timings.doTickPending.startTiming(); // Spigot
         if (!this.isDebug() && flag) {
             long k = this.getGameTime();
             profilerfiller.push("blockTicks");
@@ -348,6 +_,7 @@
             this.fluidTicks.tick(k, 65536, this::tickFluid);
             profilerfiller.pop();
         }
+        timings.doTickPending.stopTiming(); // Spigot
 
         profilerfiller.popPush("raid");
         if (flag) {
@@ -358,27 +_,33 @@
         this.getChunkSource().tick(p_8794_, true);
         profilerfiller.popPush("blockEvents");
         if (flag) {
+            timings.doSounds.startTiming(); // Spigot
             this.runBlockEvents();
+            timings.doSounds.stopTiming(); // Spigot
         }
 
         this.handlingTick = false;
         profilerfiller.pop();
-        boolean flag1 = !this.players.isEmpty() || !this.getForcedChunks().isEmpty();
+        boolean flag1 = !this.players.isEmpty() || net.neoforged.neoforge.common.world.chunk.ForcedChunkManager.hasForcedChunks(this); // Neo: Replace vanilla's has forced chunk check with neo's that checks both the vanilla and neo added ones
+        flag = true; // CraftBukkit - this prevents entity cleanup, other issues on servers with no players //Ketting - move true to new line, prevent mixin issue
         if (flag1) {
             this.resetEmptyTime();
         }
 
         if (flag1 || this.emptyTime++ < 300) {
             profilerfiller.push("entities");
+            timings.tickEntities.startTiming(); // Spigot
             if (this.dragonFight != null && flag) {
                 profilerfiller.push("dragonFight");
                 this.dragonFight.tick();
                 profilerfiller.pop();
             }
 
+            org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+            timings.entityTick.startTiming(); // Spigot
             this.entityTickList.forEach(p_308566_ -> {
                 if (!p_308566_.isRemoved()) {
-                    if (this.shouldDiscardEntity(p_308566_)) {
+                    if (false && this.shouldDiscardEntity(p_308566_)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
                         p_308566_.discard();
                     } else if (!tickratemanager.isEntityFrozen(p_308566_)) {
                         profilerfiller.push("checkDespawn");
@@ -395,12 +_,16 @@
                             }
 
                             profilerfiller.push("tick");
-                            this.guardEntityTick(this::tickNonPassenger, p_308566_);
+                            if (!p_308566_.isRemoved() && !(p_308566_ instanceof net.neoforged.neoforge.entity.PartEntity)) {
+                                this.guardEntityTick(this::tickNonPassenger, p_308566_);
+                            }
                             profilerfiller.pop();
                         }
                     }
                 }
             });
+            timings.entityTick.stopTiming(); // Spigot
+            timings.tickEntities.stopTiming(); // Spigot
             profilerfiller.pop();
             this.tickBlockEntities();
         }
@@ -456,7 +_,7 @@
         int j = chunkpos.getMinBlockZ();
         ProfilerFiller profilerfiller = this.getProfiler();
         profilerfiller.push("thunder");
-        if (flag && this.isThundering() && this.random.nextInt(100000) == 0) {
+        if (flag && this.isThundering() && this.spigotConfig.thunderChance > 0 && this.random.nextInt(this.spigotConfig.thunderChance) == 0) { // Spigot
             BlockPos blockpos = this.findLightningTargetAround(this.getBlockRandomPos(i, 0, j, 15));
             if (this.isRainingAt(blockpos)) {
                 DifficultyInstance difficultyinstance = this.getCurrentDifficultyAt(blockpos);
@@ -469,6 +_,7 @@
                         skeletonhorse.setTrap(true);
                         skeletonhorse.setAge(0);
                         skeletonhorse.setPos((double)blockpos.getX(), (double)blockpos.getY(), (double)blockpos.getZ());
+                        this.prepareAddFreshEntity(org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.LIGHTNING); // CraftBukkit // Ketting
                         this.addFreshEntity(skeletonhorse);
                     }
                 }
@@ -477,7 +_,7 @@
                 if (lightningbolt != null) {
                     lightningbolt.moveTo(Vec3.atBottomCenterOf(blockpos));
                     lightningbolt.setVisualOnly(flag1);
-                    this.addFreshEntity(lightningbolt);
+                    this.strikeLightning(lightningbolt, org.bukkit.event.weather.LightningStrikeEvent.Cause.WEATHER); // CraftBukkit
                 }
             }
         }
@@ -527,8 +_,14 @@
         BlockPos blockpos = this.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING, p_295060_);
         BlockPos blockpos1 = blockpos.below();
         Biome biome = this.getBiome(blockpos).value();
+        if (this.isAreaLoaded(blockpos1, 1)) // Forge: check area to avoid loading neighbors in unloaded chunks
         if (biome.shouldFreeze(this, blockpos1)) {
-            this.setBlockAndUpdate(blockpos1, Blocks.ICE.defaultBlockState());
+            // Ketting start
+            org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.handleBlockFormUpdate.set(false);
+            if (org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.handleBlockFormEvent(this, blockpos1, Blocks.ICE.defaultBlockState(), null))  { // CraftBukkit
+                this.setBlockAndUpdate(blockpos1, Blocks.ICE.defaultBlockState());
+            }
+            // Ketting end
         }
 
         if (this.isRaining()) {
@@ -541,9 +_,20 @@
                         BlockState blockstate1 = blockstate.setValue(SnowLayerBlock.LAYERS, Integer.valueOf(j + 1));
                         Block.pushEntitiesUp(blockstate, blockstate1, this, blockpos);
                         this.setBlockAndUpdate(blockpos, blockstate1);
+                        // Ketting start
+                        org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.handleBlockFormUpdate.set(false);
+                        if (org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.handleBlockFormEvent(this, blockpos, blockstate1, null))  { // CraftBukkit
+                            this.setBlockAndUpdate(blockpos1, Blocks.ICE.defaultBlockState());
+                        }
+                        // Ketting end
                     }
                 } else {
-                    this.setBlockAndUpdate(blockpos, Blocks.SNOW.defaultBlockState());
+                    // Ketting start
+                    org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.handleBlockFormUpdate.set(false);
+                    if (org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.handleBlockFormEvent(this, blockpos, Blocks.SNOW.defaultBlockState(), null))  { // CraftBukkit
+                        this.setBlockAndUpdate(blockpos1, Blocks.ICE.defaultBlockState());
+                    }
+                    // Ketting end
                 }
             }
 
@@ -687,6 +_,7 @@
             this.rainLevel = Mth.clamp(this.rainLevel, 0.0F, 1.0F);
         }
 
+        /* CraftBukkit start
         if (this.oRainLevel != this.rainLevel) {
             this.server
                 .getPlayerList()
@@ -699,24 +_,60 @@
                 .broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, this.thunderLevel), this.dimension());
         }
 
+         * The function in use here has been replaced in order to only send the weather info to players in the correct dimension,
+         * rather than to all players on the server. This is what causes the client-side rain, as the
+         * client believes that it has started raining locally, rather than in another dimension.
         if (flag != this.isRaining()) {
             if (flag) {
-                this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.STOP_RAINING, 0.0F));
+                this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.STOP_RAINING, 0.0F), this.dimension());
             } else {
-                this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.START_RAINING, 0.0F));
-            }
-
-            this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, this.rainLevel));
-            this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, this.thunderLevel));
-        }
+                this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.START_RAINING, 0.0F), this.dimension());
+            }
+
+            this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, this.rainLevel), this.dimension());
+            this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, this.thunderLevel), this.dimension());
+        }
+        */
+        for (int idx = 0; idx < this.players.size(); ++idx) {
+            if ((this.players.get(idx)).level() == this) {
+                (this.players.get(idx)).tickWeather();
+            }
+        }
+
+        if (flag != this.isRaining()) {
+            // Only send weather packets to those affected
+            for (int idx = 0; idx < this.players.size(); ++idx) {
+                if ((this.players.get(idx)).level() == this) {
+                    (this.players.get(idx)).setPlayerWeather((!flag ? org.bukkit.WeatherType.DOWNFALL : org.bukkit.WeatherType.CLEAR), false);
+                }
+            }
+        }
+        for (int idx = 0; idx < this.players.size(); ++idx) {
+            if ((this.players.get(idx)).level() == this) {
+                (this.players.get(idx)).updateWeather(this.oRainLevel, this.rainLevel, this.oThunderLevel, this.thunderLevel);
+            }
+        }
+        // CraftBukkit end
     }
 
     @VisibleForTesting
     public void resetWeatherCycle() {
-        this.serverLevelData.setRainTime(0);
+        // CraftBukkit start
         this.serverLevelData.setRaining(false);
-        this.serverLevelData.setThunderTime(0);
+        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
+        // Not that everyone ever manages to get the whole server to sleep at the same time....
+        if (!this.serverLevelData.isRaining()) {
+            this.serverLevelData.setRainTime(0);
+        }
+        // CraftBukkit end
         this.serverLevelData.setThundering(false);
+        // CraftBukkit start
+        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
+        // Not that everyone ever manages to get the whole server to sleep at the same time....
+        if (!this.serverLevelData.isThundering()) {
+            this.serverLevelData.setThunderTime(0);
+        }
+        // CraftBukkit end
     }
 
     public void resetEmptyTime() {
@@ -738,17 +_,27 @@
     }
 
     public void tickNonPassenger(Entity p_8648_) {
+        // Spigot start
+        if (!org.spigotmc.ActivationRange.checkIfActive(p_8648_)) {
+            p_8648_.tickCount++;
+            p_8648_.inactiveTick();
+            return;
+        }
+        // Spigot end
+        p_8648_.tickTimer.startTiming(); // Spigot
         p_8648_.setOldPosAndRot();
         ProfilerFiller profilerfiller = this.getProfiler();
         ++p_8648_.tickCount;
         this.getProfiler().push(() -> BuiltInRegistries.ENTITY_TYPE.getKey(p_8648_.getType()).toString());
         profilerfiller.incrementCounter("tickNonPassenger");
         p_8648_.tick();
+        p_8648_.postTick(); // CraftBukkit
         this.getProfiler().pop();
 
         for(Entity entity : p_8648_.getPassengers()) {
             this.tickPassenger(p_8648_, entity);
         }
+        p_8648_.tickTimer.stopTiming(); // Spigot
     }
 
     private void tickPassenger(Entity p_8663_, Entity p_8664_) {
@@ -760,7 +_,9 @@
             ProfilerFiller profilerfiller = this.getProfiler();
             profilerfiller.push(() -> BuiltInRegistries.ENTITY_TYPE.getKey(p_8664_.getType()).toString());
             profilerfiller.incrementCounter("tickPassenger");
+                if (p_8664_.canUpdate())
             p_8664_.rideTick();
+            p_8664_.postTick(); // CraftBukkit
             profilerfiller.pop();
 
             for(Entity entity : p_8664_.getPassengers()) {
@@ -777,6 +_,7 @@
     public void save(@Nullable ProgressListener p_8644_, boolean p_8645_, boolean p_8646_) {
         ServerChunkCache serverchunkcache = this.getChunkSource();
         if (!p_8646_) {
+            org.bukkit.Bukkit.getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent(getWorld())); // CraftBukkit
             if (p_8644_ != null) {
                 p_8644_.progressStartNoAbort(Component.translatable("menu.savingLevel"));
             }
@@ -792,12 +_,13 @@
             } else {
                 this.entityManager.autoSave();
             }
+            net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.level.LevelEvent.Save(this));
         }
     }
 
     private void saveLevelData() {
         if (this.dragonFight != null) {
-            this.server.getWorldData().setEndDragonFightData(this.dragonFight.saveData());
+            getServerLevelData().setEndDragonFightData(this.dragonFight.saveData()); // CraftBukkit //Ketting - don't enforce PrimaryLevelData
         }
 
         this.getChunkSource().getDataStorage().save();
@@ -854,20 +_,59 @@
         List<ServerPlayer> list = this.getPlayers(LivingEntity::isAlive);
         return list.isEmpty() ? null : list.get(this.random.nextInt(list.size()));
     }
-
-    @Override
+    
+    //Ketting start - move spawnreason, disable spawns
+    private java.util.concurrent.atomic.AtomicReference<org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason> ketting$addFreshEntity$spawnReason = new java.util.concurrent.atomic.AtomicReference<>(org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
+    @Override
+    public void prepareAddFreshEntity(org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason) {
+        ketting$addFreshEntity$spawnReason.set(spawnReason);
+    }
+
+    private java.util.List<Entity> ketting$disabledEntitySpawns = new java.util.ArrayList<>();
+    @Override
+    public void disableSpawnFor(Entity entity) {
+        ketting$disabledEntitySpawns.add(entity);
+    }
+
     public boolean addFreshEntity(Entity p_8837_) {
+        if (ketting$disabledEntitySpawns.contains(p_8837_)) {
+            ketting$disabledEntitySpawns.remove(p_8837_);
+            return false;
+        }
+        ketting$addEntity$spawnReason.set(ketting$addFreshEntity$spawnReason.getAndSet(org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT));
+        // Ketting end
         return this.addEntity(p_8837_);
     }
 
+    //Ketting start
+    private java.util.concurrent.atomic.AtomicReference<org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason> ketting$addWithUUID$spawnReason = new java.util.concurrent.atomic.AtomicReference<>(org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
+
+    public boolean addWithUUID(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+        ketting$addWithUUID$spawnReason.set(reason);
+        return this.addWithUUID(entity);
+    }
+    //Ketting end
+
     public boolean addWithUUID(Entity p_8848_) {
+        ketting$addEntity$spawnReason.getAndSet(ketting$addWithUUID$spawnReason.getAndSet(org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT)); //Ketting
         return this.addEntity(p_8848_);
     }
 
     public void addDuringTeleport(Entity p_143335_) {
+        // CraftBukkit start
+        // SPIGOT-6415: Don't call spawn event for entities which travel trough worlds,
+        // since it is only an implementation detail, that a new entity is created when
+        // they are traveling between worlds.
+        ketting$addEntity$spawnReason.set(null);
         this.addEntity(p_143335_);
     }
 
+    public void addDuringTeleport(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+        ketting$addEntity$spawnReason.set(reason);
+        this.addEntity(entity);
+        // CraftBukkit end
+    }
+
     public void addDuringCommandTeleport(ServerPlayer p_8623_) {
         this.addPlayer(p_8623_);
     }
@@ -885,6 +_,7 @@
     }
 
     private void addPlayer(ServerPlayer p_8854_) {
+        if (net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.entity.EntityJoinLevelEvent(p_8854_, this)).isCanceled()) return;
         Entity entity = this.getEntities().get(p_8854_.getUUID());
         if (entity != null) {
             LOGGER.warn("Force-added player with duplicate UUID {}", p_8854_.getUUID());
@@ -892,28 +_,67 @@
             this.removePlayerImmediately((ServerPlayer)entity, Entity.RemovalReason.DISCARDED);
         }
 
-        this.entityManager.addNewEntity(p_8854_);
+        this.entityManager.addNewEntityWithoutEvent(p_8854_);
+        p_8854_.onAddedToWorld();
     }
 
+    //Ketting start - add original method back, reverse delegation so that the CB method calls the original method.
+    private final java.util.concurrent.atomic.AtomicReference<org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason> ketting$addEntity$spawnReason = new java.util.concurrent.atomic.AtomicReference<>(org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.CUSTOM);
+    private boolean ketting$addEntity(Entity p_8873_){
+        //Ketting: add original method back
+        org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason = ketting$addEntity$spawnReason.getAndSet(org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.CUSTOM);
+        if (reason != null && !org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.doEntityAddEventCalling(this, p_8873_, reason)) {
+            return true;
+        }
+        return false;
+        // CraftBukkit end
+    }
+    //Ketting end
     private boolean addEntity(Entity p_8873_) {
         if (p_8873_.isRemoved()) {
-            LOGGER.warn("Tried to add entity {} but it was marked as removed already", EntityType.getKey(p_8873_.getType()));
+            // LOGGER.warn("Tried to add entity {} but it was marked as removed already", (Object)EntityType.getKey(p_8873_.getType())); // CraftBukkit
             return false;
         } else {
-            return this.entityManager.addNewEntity(p_8873_);
+            //return this.entityManager.addNewEntity(p_8873_);
+            // SPIGOT-6415: Don't call spawn event when reason is null. For example when an entity teleports to a new world.
+            if (ketting$addEntity(p_8873_)) return false;
+
+            if (this.entityManager.addNewEntity(p_8873_)) {
+                p_8873_.onAddedToWorld();
+                return true;
+            } else {
+                return false;
+            }
         }
     }
 
+    //Ketting start
+    public final java.util.concurrent.atomic.AtomicReference<org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason> ketting$tryAddFreshEntityWithPassengers$spawnReason = new java.util.concurrent.atomic.AtomicReference<>(org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
+    public boolean tryAddFreshEntityWithPassengers(Entity p_8861_, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+        ketting$tryAddFreshEntityWithPassengers$spawnReason.set(reason);
+        return tryAddFreshEntityWithPassengers(p_8861_);
+    }
+    //Ketting end
     public boolean tryAddFreshEntityWithPassengers(Entity p_8861_) {
         if (p_8861_.getSelfAndPassengers().map(Entity::getUUID).anyMatch(this.entityManager::isLoaded)) {
             return false;
         } else {
+            this.prepareAddFreshEntityWithPassengers(ketting$tryAddFreshEntityWithPassengers$spawnReason.getAndSet(org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT));
             this.addFreshEntityWithPassengers(p_8861_);
             return true;
         }
     }
 
     public void unload(LevelChunk p_8713_) {
+        // Spigot Start
+        for (net.minecraft.world.level.block.entity.BlockEntity tileentity : p_8713_.getBlockEntities().values()) {
+            if (tileentity instanceof net.minecraft.world.Container) {
+                for (org.bukkit.entity.HumanEntity h : Lists.newArrayList(((net.minecraft.world.Container) tileentity).getViewers())) {
+                    h.closeInventory();
+                }
+            }
+        }
+        // Spigot End
         p_8713_.clearAllBlockEntities();
         p_8713_.unregisterTickContainerFromLevel(this);
     }
@@ -922,13 +_,42 @@
         p_143262_.remove(p_143263_);
     }
 
+    // CraftBukkit start
+    public boolean strikeLightning(Entity entitylightning) {
+        return this.strikeLightning(entitylightning, org.bukkit.event.weather.LightningStrikeEvent.Cause.UNKNOWN);
+    }
+
+    public boolean strikeLightning(Entity entitylightning, org.bukkit.event.weather.LightningStrikeEvent.Cause cause) {
+        org.bukkit.event.weather.LightningStrikeEvent lightning = org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.callLightningStrikeEvent((org.bukkit.entity.LightningStrike) entitylightning.getBukkitEntity(), cause);
+
+        if (lightning.isCancelled()) {
+            return false;
+        }
+
+        return this.addFreshEntity(entitylightning);
+    }
+    // CraftBukkit end
+
     @Override
     public void destroyBlockProgress(int p_8612_, BlockPos p_8613_, int p_8614_) {
+        // CraftBukkit start
+        Player player = null;
+        Entity entity = this.getEntity(p_8612_);
+        if (entity instanceof Player) player = (Player) entity;
+        // CraftBukkit end
+
         for(ServerPlayer serverplayer : this.server.getPlayerList().getPlayers()) {
             if (serverplayer != null && serverplayer.level() == this && serverplayer.getId() != p_8612_) {
                 double d0 = (double)p_8613_.getX() - serverplayer.getX();
                 double d1 = (double)p_8613_.getY() - serverplayer.getY();
                 double d2 = (double)p_8613_.getZ() - serverplayer.getZ();
+
+                // CraftBukkit start
+                if (player != null && !serverplayer.getBukkitEntity().canSee(player.getBukkitEntity())) {
+                    continue;
+                }
+                // CraftBukkit end
+
                 if (d0 * d0 + d1 * d1 + d2 * d2 < 1024.0) {
                     serverplayer.connection.send(new ClientboundBlockDestructionPacket(p_8612_, p_8613_, p_8614_));
                 }
@@ -948,6 +_,12 @@
         float p_263390_,
         long p_263403_
     ) {
+        net.neoforged.neoforge.event.PlayLevelSoundEvent.AtPosition event = net.neoforged.neoforge.event.EventHooks.onPlaySoundAtPosition(this, p_263393_, p_263369_, p_263354_, p_263412_, p_263338_, p_263352_, p_263390_);
+        if (event.isCanceled() || event.getSound() == null) return;
+        p_263412_ = event.getSound();
+        p_263338_ = event.getSource();
+        p_263352_ = event.getNewVolume();
+        p_263390_ = event.getNewPitch();
         this.server
             .getPlayerList()
             .broadcast(
@@ -965,6 +_,12 @@
     public void playSeededSound(
         @Nullable Player p_263545_, Entity p_263544_, Holder<SoundEvent> p_263491_, SoundSource p_263542_, float p_263530_, float p_263520_, long p_263490_
     ) {
+        net.neoforged.neoforge.event.PlayLevelSoundEvent.AtEntity event = net.neoforged.neoforge.event.EventHooks.onPlaySoundAtEntity(p_263544_, p_263491_, p_263542_, p_263530_, p_263520_);
+        if (event.isCanceled() || event.getSound() == null) return;
+        p_263491_ = event.getSound();
+        p_263542_ = event.getSource();
+        p_263530_ = event.getNewVolume();
+        p_263520_ = event.getNewPitch();
         this.server
             .getPlayerList()
             .broadcast(
@@ -1008,6 +_,7 @@
 
     @Override
     public void gameEvent(GameEvent p_215041_, Vec3 p_215042_, GameEvent.Context p_215043_) {
+        if (!net.neoforged.neoforge.common.CommonHooks.onVanillaGameEvent(this, p_215041_, p_215042_, p_215043_)) return;
         this.gameEventDispatcher.post(p_215041_, p_215042_, p_215043_);
     }
 
@@ -1023,8 +_,21 @@
         VoxelShape voxelshape = p_8757_.getCollisionShape(this, p_8755_);
         if (Shapes.joinIsNotEmpty(voxelshape1, voxelshape, BooleanOp.NOT_SAME)) {
             List<PathNavigation> list = new ObjectArrayList<>();
+            java.util.Iterator iterator = this.navigatingMobs.iterator();
 
-            for(Mob mob : this.navigatingMobs) {
+            while (iterator.hasNext()) {
+                // CraftBukkit start - fix SPIGOT-6362
+                Mob mob;
+                try {
+                    mob = (Mob) iterator.next();
+                } catch (java.util.ConcurrentModificationException ex) {
+                    // This can happen because the pathfinder update below may trigger a chunk load, which in turn may cause more navigators to register
+                    // In this case we just run the update again across all the iterators as the chunk will then be loaded
+                    // As this is a relative edge case it is much faster than copying navigators (on either read or write)
+                    sendBlockUpdated(p_8755_, p_8756_, p_8757_, p_8758_);
+                    return;
+                }
+                // CraftBukkit end
                 PathNavigation pathnavigation = mob.getNavigation();
                 if (pathnavigation.shouldRecomputePath(p_8755_)) {
                     list.add(pathnavigation);
@@ -1045,11 +_,16 @@
 
     @Override
     public void updateNeighborsAt(BlockPos p_215045_, Block p_215046_) {
+        net.neoforged.neoforge.event.EventHooks.onNeighborNotify(this, p_215045_, this.getBlockState(p_215045_), java.util.EnumSet.allOf(Direction.class), false).isCanceled();
         this.neighborUpdater.updateNeighborsAtExceptFromFacing(p_215045_, p_215046_, null);
     }
 
     @Override
     public void updateNeighborsAtExceptFromFacing(BlockPos p_215052_, Block p_215053_, Direction p_215054_) {
+        java.util.EnumSet<Direction> directions = java.util.EnumSet.allOf(Direction.class);
+        directions.remove(p_215054_);
+        if (net.neoforged.neoforge.event.EventHooks.onNeighborNotify(this, p_215052_, this.getBlockState(p_215052_), directions, false).isCanceled())
+            return;
         this.neighborUpdater.updateNeighborsAtExceptFromFacing(p_215052_, p_215053_, p_215054_);
     }
 
@@ -1095,6 +_,12 @@
         Explosion explosion = this.explode(
             p_256039_, p_255778_, p_256002_, p_256067_, p_256370_, p_256153_, p_256045_, p_255686_, p_255827_, false, p_312436_, p_312391_, p_312491_
         );
+        // CraftBukkit start
+        if (explosion.wasCanceled) {
+            return explosion;
+        }
+        // CraftBukkit end
+
         if (!explosion.interactsWithBlocks()) {
             explosion.clearToBlow();
         }
@@ -1181,17 +_,35 @@
         return this.server.getStructureManager();
     }
 
+    private final java.util.concurrent.atomic.AtomicReference<ServerPlayer> ketting$sendParticles$sender = new java.util.concurrent.atomic.AtomicReference<>(null);
+    private final java.util.concurrent.atomic.AtomicBoolean ketting$sendParticles$force = new java.util.concurrent.atomic.AtomicBoolean(false);
+
+    public <T extends ParticleOptions> int sendParticles(ServerPlayer sender, T p_8768_, double p_8769_, double p_8770_, double p_8771_, int p_8772_, double p_8773_, double p_8774_, double p_8775_, double p_8776_, boolean force) {
+        ketting$sendParticles$sender.set(sender);
+        ketting$sendParticles$force.set(force);
+        // CraftBukkit - visibility api support
+        return sendParticles(p_8768_, p_8769_, p_8770_, p_8771_, p_8772_, p_8773_, p_8774_, p_8775_, p_8776_);
+    }
+    private boolean ketting$sendParticles(ServerPlayer serverplayer){
+        ServerPlayer sender = ketting$sendParticles$sender.getAndSet(null);
+        if (sender != null && !serverplayer.getBukkitEntity().canSee(sender.getBukkitEntity())) return true;
+        return false;
+    }
+
     public <T extends ParticleOptions> int sendParticles(
         T p_8768_, double p_8769_, double p_8770_, double p_8771_, int p_8772_, double p_8773_, double p_8774_, double p_8775_, double p_8776_
     ) {
         ClientboundLevelParticlesPacket clientboundlevelparticlespacket = new ClientboundLevelParticlesPacket(
             p_8768_, false, p_8769_, p_8770_, p_8771_, (float)p_8773_, (float)p_8774_, (float)p_8775_, (float)p_8776_, p_8772_
         );
+        // CraftBukkit end
         int i = 0;
 
         for(int j = 0; j < this.players.size(); ++j) {
             ServerPlayer serverplayer = this.players.get(j);
-            if (this.sendParticles(serverplayer, false, p_8769_, p_8770_, p_8771_, clientboundlevelparticlespacket)) {
+            if (ketting$sendParticles(serverplayer)) continue; // Ketting - from CraftBukkit
+
+            if (this.sendParticles(serverplayer, ketting$sendParticles$force.getAndSet(false), p_8769_, p_8770_, p_8771_, clientboundlevelparticlespacket)) { // CraftBukkit
                 ++i;
             }
         }
@@ -1252,7 +_,7 @@
 
     @Nullable
     public BlockPos findNearestMapStructure(TagKey<Structure> p_215012_, BlockPos p_215013_, int p_215014_, boolean p_215015_) {
-        if (!this.server.getWorldData().worldGenOptions().generateStructures()) {
+        if (!getServerLevelData().worldGenOptions().generateStructures()) { // CraftBukkit //Ketting - don't enforce PrimaryLevelData
             return null;
         } else {
             Optional<HolderSet.Named<Structure>> optional = this.registryAccess().registryOrThrow(Registries.STRUCTURE).getTag(p_215012_);
@@ -1297,11 +_,19 @@
     @Nullable
     @Override
     public MapItemSavedData getMapData(String p_8785_) {
-        return this.getServer().overworld().getDataStorage().get(MapItemSavedData.factory(), p_8785_);
+        //return this.getServer().overworld().getDataStorage().get(MapItemSavedData.factory(), p_8785_);
+        // CraftBukkit start
+        net.minecraft.world.level.saveddata.maps.MapItemSavedData worldmap = this.getServer().overworld().getDataStorage().get(MapItemSavedData.factory(), p_8785_);
+        if (worldmap != null) {
+            worldmap.id = p_8785_;
+        }
+        return worldmap;
+        // CraftBukkit end
     }
 
     @Override
     public void setMapData(String p_143305_, MapItemSavedData p_143306_) {
+        p_143306_.id = p_143305_; // CraftBukkit
         this.getServer().overworld().getDataStorage().set(p_143305_, p_143306_);
     }
 
@@ -1505,6 +_,11 @@
     @Override
     public void blockUpdated(BlockPos p_8743_, Block p_8744_) {
         if (!this.isDebug()) {
+            // CraftBukkit start
+            if (populating) {
+                return;
+            }
+            // CraftBukkit end
             this.updateNeighborsAt(p_8743_, p_8744_);
         }
     }
@@ -1524,12 +_,12 @@
     }
 
     public boolean isFlat() {
-        return this.server.getWorldData().isFlatWorld();
+        return getServerLevelData().isFlatWorld(); // CraftBukkit //Ketting - don't enforce PrimaryLevelData
     }
 
     @Override
     public long getSeed() {
-        return this.server.getWorldData().worldGenOptions().seed();
+        return getServerLevelData().worldGenOptions().seed(); // CraftBukkit //Ketting - don't enforce PrimaryLevelData
     }
 
     @Nullable
@@ -1578,19 +_,39 @@
         }
     }
 
+    //Ketting start
+    public static final java.util.concurrent.atomic.AtomicReference<Entity> ketting$makeObsidianPlatform$entity = new java.util.concurrent.atomic.AtomicReference<>(null);
+    @SuppressWarnings("unused")
+    public static void makeObsidianPlatform(ServerLevel p_8618_, Entity entity) {
+        ketting$makeObsidianPlatform$entity.set(entity);
+        ServerLevel.makeObsidianPlatform(p_8618_);
+    }
+    //Ketting end
     public static void makeObsidianPlatform(ServerLevel p_8618_) {
         BlockPos blockpos = END_SPAWN_POINT;
         int i = blockpos.getX();
         int j = blockpos.getY() - 2;
         int k = blockpos.getZ();
+        // CraftBukkit start
+        org.bukkit.craftbukkit.v1_20_R3.util.BlockStateListPopulator blockList = new org.bukkit.craftbukkit.v1_20_R3.util.BlockStateListPopulator(p_8618_);
         BlockPos.betweenClosed(i - 2, j + 1, k - 2, i + 2, j + 3, k + 2)
-            .forEach(p_207578_ -> p_8618_.setBlockAndUpdate(p_207578_, Blocks.AIR.defaultBlockState()));
+            .forEach(p_207578_ -> blockList.setBlock(p_207578_, Blocks.AIR.defaultBlockState(), 3));
         BlockPos.betweenClosed(i - 2, j, k - 2, i + 2, j, k + 2)
-            .forEach(p_184101_ -> p_8618_.setBlockAndUpdate(p_184101_, Blocks.OBSIDIAN.defaultBlockState()));
+            .forEach(p_184101_ -> blockList.setBlock(p_184101_, Blocks.OBSIDIAN.defaultBlockState(), 3));
+        org.bukkit.World bworld = p_8618_.getWorld();
+        Entity entity = ketting$makeObsidianPlatform$entity.getAndSet(null);
+        org.bukkit.event.world.PortalCreateEvent portalEvent = new org.bukkit.event.world.PortalCreateEvent((List<org.bukkit.block.BlockState>) (List) blockList.getList(), bworld, (entity == null) ? null : entity.getBukkitEntity(), org.bukkit.event.world.PortalCreateEvent.CreateReason.END_PLATFORM);
+
+        p_8618_.getCraftServer().getPluginManager().callEvent(portalEvent);
+        if (!portalEvent.isCancelled()) {
+            blockList.updateList();
+        }
+        // CraftBukkit end
     }
 
     @Override
     public LevelEntityGetter<Entity> getEntities() {
+        org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot
         return this.entityManager.getEntityGetter();
     }
 
@@ -1663,6 +_,7 @@
 
     final class EntityCallbacks implements LevelCallback<Entity> {
         public void onCreated(Entity p_143355_) {
+            p_143355_.inWorld = true; // CraftBukkit - Mark entity as in world
         }
 
         public void onDestroyed(Entity p_143359_) {
@@ -1678,6 +_,7 @@
         }
 
         public void onTrackingStart(Entity p_143371_) {
+            org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
             ServerLevel.this.getChunkSource().addEntity(p_143371_);
             if (p_143371_ instanceof ServerPlayer serverplayer) {
                 ServerLevel.this.players.add(serverplayer);
@@ -1695,16 +_,48 @@
                 ServerLevel.this.navigatingMobs.add(mob);
             }
 
-            if (p_143371_ instanceof EnderDragon enderdragon) {
-                for(EnderDragonPart enderdragonpart : enderdragon.getSubEntities()) {
+            if (p_143371_.isMultipartEntity()) {
+                for(net.neoforged.neoforge.entity.PartEntity<?> enderdragonpart : p_143371_.getParts()) {
                     ServerLevel.this.dragonParts.put(enderdragonpart.getId(), enderdragonpart);
                 }
             }
 
             p_143371_.updateDynamicGameEventListener(DynamicGameEventListener::add);
+            p_143371_.valid = true; // CraftBukkit
         }
 
         public void onTrackingEnd(Entity p_143375_) {
+            org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
+            // Spigot start
+            if ( p_143375_ instanceof Player )
+            {
+                com.google.common.collect.Streams.stream( getServer().getAllLevels() ).map( ServerLevel::getDataStorage ).forEach( (worldData) ->
+                {
+                    for (Object o : worldData.cache.values() )
+                    {
+                        if ( o instanceof MapItemSavedData )
+                        {
+                            MapItemSavedData map = (MapItemSavedData) o;
+                            map.carriedByPlayers.remove( (Player) p_143375_ );
+                            for ( java.util.Iterator<MapItemSavedData.HoldingPlayer> iter = map.carriedBy.iterator(); iter.hasNext(); )
+                            {
+                                if ( iter.next().player == p_143375_ )
+                                {
+                                    iter.remove();
+                                }
+                            }
+                        }
+                    }
+                } );
+            }
+            // Spigot end
+            // Spigot Start
+            if (p_143375_.getBukkitEntity() instanceof org.bukkit.inventory.InventoryHolder && (!(p_143375_ instanceof ServerPlayer) || p_143375_.getRemovalReason() != Entity.RemovalReason.KILLED)) { // SPIGOT-6876: closeInventory clears death message
+                for (org.bukkit.entity.HumanEntity h : Lists.newArrayList(((org.bukkit.inventory.InventoryHolder) p_143375_.getBukkitEntity()).getInventory().getViewers())) {
+                    h.closeInventory();
+                }
+            }
+            // Spigot End
             ServerLevel.this.getChunkSource().removeEntity(p_143375_);
             if (p_143375_ instanceof ServerPlayer serverplayer) {
                 ServerLevel.this.players.remove(serverplayer);
@@ -1715,24 +_,70 @@
                 if (ServerLevel.this.isUpdatingNavigations) {
                     String s = "onTrackingStart called during navigation iteration";
                     Util.logAndPauseIfInIde(
-                        "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
+                              "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
                     );
                 }
 
                 ServerLevel.this.navigatingMobs.remove(mob);
             }
 
-            if (p_143375_ instanceof EnderDragon enderdragon) {
-                for(EnderDragonPart enderdragonpart : enderdragon.getSubEntities()) {
+            if (p_143375_.isMultipartEntity()) {
+                for(net.neoforged.neoforge.entity.PartEntity<?> enderdragonpart : p_143375_.getParts()) {
                     ServerLevel.this.dragonParts.remove(enderdragonpart.getId());
                 }
             }
 
             p_143375_.updateDynamicGameEventListener(DynamicGameEventListener::remove);
+
+            // CraftBukkit start
+            p_143375_.valid = false;
+            if (!(p_143375_ instanceof ServerPlayer)) {
+                for (ServerPlayer player : players) {
+                    player.getBukkitEntity().onEntityRemove(p_143375_);
+                }
+            }
+            // CraftBukkit end
+
+            p_143375_.onRemovedFromWorld();
+            net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.entity.EntityLeaveLevelEvent(p_143375_, ServerLevel.this));
         }
 
         public void onSectionChange(Entity p_215086_) {
             p_215086_.updateDynamicGameEventListener(DynamicGameEventListener::move);
         }
+    }
+
+    @Override
+    public java.util.Collection<net.neoforged.neoforge.entity.PartEntity<?>> getPartEntities() {
+        return this.dragonParts.values();
+    }
+
+    private final net.neoforged.neoforge.capabilities.CapabilityListenerHolder capListenerHolder = new net.neoforged.neoforge.capabilities.CapabilityListenerHolder();
+
+    @Override
+    public void invalidateCapabilities(BlockPos pos) {
+        capListenerHolder.invalidatePos(pos);
+    }
+
+    @Override
+    public void invalidateCapabilities(ChunkPos pos) {
+        capListenerHolder.invalidateChunk(pos);
+    }
+
+    /**
+     * Register a listener for capability invalidation.
+     * @see net.neoforged.neoforge.capabilities.ICapabilityInvalidationListener
+     */
+    public void registerCapabilityListener(BlockPos pos, net.neoforged.neoforge.capabilities.ICapabilityInvalidationListener listener) {
+        capListenerHolder.addListener(pos, listener);
+    }
+
+    /**
+     * Internal method, used to clean capability listeners that are not referenced.
+     * Do not call.
+     */
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public void cleanCapabilityListenerReferences() {
+        capListenerHolder.clean();
     }
 }
