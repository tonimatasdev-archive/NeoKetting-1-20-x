--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -124,7 +_,32 @@
 import org.joml.Vector3f;
 import org.slf4j.Logger;
 
-public abstract class Entity implements Nameable, EntityAccess, CommandSource, ScoreHolder {
+public abstract class Entity extends net.neoforged.neoforge.attachment.AttachmentHolder implements Nameable, EntityAccess, CommandSource, ScoreHolder, net.neoforged.neoforge.common.extensions.IEntityExtension {
+    // CraftBukkit start
+    private static final int CURRENT_LEVEL = 2;
+    static boolean isLevelAtLeast(CompoundTag tag, int level) {
+        return tag.contains("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
+    }
+
+    private org.bukkit.craftbukkit.v1_20_R3.entity.CraftEntity bukkitEntity;
+
+    public org.bukkit.craftbukkit.v1_20_R3.entity.CraftEntity getBukkitEntity() {
+        if (bukkitEntity == null) {
+            bukkitEntity = org.bukkit.craftbukkit.v1_20_R3.entity.CraftEntity.getEntity(level.getCraftServer(), this);
+        }
+        return bukkitEntity;
+    }
+
+    @Override
+    public org.bukkit.command.CommandSender getBukkitSender(CommandSourceStack wrapper) {
+        return getBukkitEntity();
+    }
+
+    // CraftBukkit - SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
+    public int getDefaultMaxAirSupply() {
+        return TOTAL_AIR_SUPPLY;
+    }
+    // CraftBukkit end
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final String ID_TAG = "id";
     public static final String PASSENGERS_TAG = "Passengers";
@@ -145,6 +_,7 @@
     private static final double LAVA_SLOW_FLOW_SCALE = 0.0023333333333333335;
     public static final String UUID_TAG = "UUID";
     private static double viewScale = 1.0;
+    @Deprecated // Forge: Use the getter to allow overriding in mods
     private final EntityType<?> type;
     private int id = ENTITY_COUNTER.incrementAndGet();
     public boolean blocksBuilding;
@@ -191,8 +_,10 @@
     public int tickCount;
     private int remainingFireTicks = -this.getFireImmuneTicks();
     protected boolean wasTouchingWater;
+    @Deprecated // Forge: Use forgeFluidTypeHeight instead
     protected Object2DoubleMap<TagKey<Fluid>> fluidHeight = new Object2DoubleArrayMap<>(2);
     protected boolean wasEyeInWater;
+    @Deprecated // Forge: Use forgeFluidTypeOnEyes instead
     private final Set<TagKey<Fluid>> fluidOnEyes = new HashSet<>();
     public int invulnerableTime;
     protected boolean firstTick = true;
@@ -241,14 +_,52 @@
     private boolean hasVisualFire;
     @Nullable
     private BlockState feetBlockState = null;
+    // CraftBukkit start
+    public boolean persist = true;
+    public boolean visibleByDefault = true;
+    public boolean valid;
+    public boolean inWorld = false;
+    public boolean generation;
+    public int maxAirTicks = getDefaultMaxAirSupply(); // CraftBukkit - SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
+    public org.bukkit.projectiles.ProjectileSource projectileSource; // For projectiles only
+    public boolean lastDamageCancelled; // SPIGOT-5339, SPIGOT-6252, SPIGOT-6777: Keep track if the event was canceled
+    public boolean persistentInvisibility = false;
+    public BlockPos lastLavaContact;
+    // Marks an entity, that it was removed by a plugin via Entity#remove
+    // Main use case currently is for SPIGOT-7487, preventing dropping of leash when leash is removed
+    public boolean pluginRemoved = false;
+    public org.spigotmc.CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.v1_20_R3.SpigotTimings.getEntityTimings(this); // Spigot
+    // Spigot start
+    public final org.spigotmc.ActivationRange.ActivationType activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
+    public final boolean defaultActivationState;
+    public long activatedTick = Integer.MIN_VALUE;
+    public void inactiveTick() { }
+    // Spigot end
+
+    public float getBukkitYaw() {
+        return this.yRot;
+    }
+
+    public boolean isChunkLoaded() {
+        return level.hasChunk((int) Math.floor(this.getX()) >> 4, (int) Math.floor(this.getZ()) >> 4);
+    }
+    // CraftBukkit end
 
     public Entity(EntityType<?> p_19870_, Level p_19871_) {
+        super(Entity.class);
         this.type = p_19870_;
         this.level = p_19871_;
         this.dimensions = p_19870_.getDimensions();
         this.position = Vec3.ZERO;
         this.blockPosition = BlockPos.ZERO;
         this.chunkPosition = ChunkPos.ZERO;
+        // Spigot start
+        if (p_19871_ != null) {
+            this.defaultActivationState = org.spigotmc.ActivationRange.initializeEntityActivationState(this, p_19871_.spigotConfig);
+        } else {
+            this.defaultActivationState = false;
+        }
+        // Spigot end
         this.entityData = new SynchedEntityData(this);
         this.entityData.define(DATA_SHARED_FLAGS_ID, (byte)0);
         this.entityData.define(DATA_AIR_SUPPLY_ID, this.getMaxAirSupply());
@@ -259,8 +_,17 @@
         this.entityData.define(DATA_POSE, Pose.STANDING);
         this.entityData.define(DATA_TICKS_FROZEN, 0);
         this.defineSynchedData();
+        this.getEntityData().registrationLocked = true; // Spigot
         this.setPos(0.0, 0.0, 0.0);
-        this.eyeHeight = this.getEyeHeight(Pose.STANDING, this.dimensions);
+        net.neoforged.neoforge.event.entity.EntityEvent.Size sizeEvent = net.neoforged.neoforge.event.EventHooks.getEntitySizeForge(this, Pose.STANDING, this.dimensions, this.getEyeHeight(Pose.STANDING, this.dimensions));
+        this.dimensions = sizeEvent.getNewSize();
+        this.eyeHeight = sizeEvent.getNewEyeHeight();
+        //Ketting: Move on Player init, to allow for init after the Player Constructor
+        if (!(this instanceof LivingEntity)) postInit();
+    }
+    protected void postInit(){
+        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.entity.EntityEvent.EntityConstructing(this));
+        this.gatherCapabilities();
     }
 
     public boolean isColliding(BlockPos p_20040_, BlockState p_20041_) {
@@ -358,6 +_,12 @@
     }
 
     public void setPose(Pose p_20125_) {
+        // CraftBukkit start
+        if (p_20125_ == this.getPose()) {
+            return;
+        }
+        this.level.getCraftServer().getPluginManager().callEvent(new org.bukkit.event.entity.EntityPoseChangeEvent(this.getBukkitEntity(), org.kettingpowered.ketting.inject.ForgeInject.getBukkitEntityPose(p_20125_)));
+        // CraftBukkit end
         this.entityData.set(DATA_POSE, p_20125_);
     }
 
@@ -381,6 +_,32 @@
     }
 
     protected void setRot(float p_19916_, float p_19917_) {
+        // CraftBukkit start - yaw was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(p_19916_)) {
+            p_19916_ = 0;
+        }
+
+        if (p_19916_ == Float.POSITIVE_INFINITY || p_19916_ == Float.NEGATIVE_INFINITY) {
+            if (this instanceof ServerPlayer) {
+                this.level.getCraftServer().getLogger().warning(this.getScoreboardName() + " was caught trying to crash the server with an invalid yaw");
+                ((org.bukkit.craftbukkit.v1_20_R3.entity.CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite yaw (Hacking?)");
+            }
+            p_19916_ = 0;
+        }
+
+        // pitch was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(p_19917_)) {
+            p_19917_ = 0;
+        }
+
+        if (p_19917_ == Float.POSITIVE_INFINITY || p_19917_ == Float.NEGATIVE_INFINITY) {
+            if (this instanceof ServerPlayer) {
+                this.level.getCraftServer().getLogger().warning(this.getScoreboardName() + " was caught trying to crash the server with an invalid pitch");
+                ((org.bukkit.craftbukkit.v1_20_R3.entity.CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite pitch (Hacking?)");
+            }
+            p_19917_ = 0;
+        }
+        // CraftBukkit end
         this.setYRot(p_19916_ % 360.0F);
         this.setXRot(p_19917_ % 360.0F);
     }
@@ -420,6 +_,15 @@
         this.baseTick();
     }
 
+    // CraftBukkit start
+    public void postTick() {
+        // No clean way to break out of ticking once the entity has been copied to a new world, so instead we move the portalling later in the tick cycle
+        if (!(this instanceof ServerPlayer)) {
+            this.handleNetherPortal();
+        }
+    }
+    // CraftBukkit end
+
     public void baseTick() {
         this.level().getProfiler().push("entityBaseTick");
         this.feetBlockState = null;
@@ -434,6 +_,7 @@
         this.walkDistO = this.walkDist;
         this.xRotO = this.getXRot();
         this.yRotO = this.getYRot();
+        if (this instanceof ServerPlayer) // CraftBukkit - // Moved up to postTick
         this.handleNetherPortal();
         if (this.canSpawnSprintParticle()) {
             this.spawnSprintParticle();
@@ -468,7 +_,11 @@
 
         if (this.isInLava()) {
             this.lavaHurt();
-            this.fallDistance *= 0.5F;
+            this.fallDistance *= this.getFluidFallDistanceModifier(net.neoforged.neoforge.common.NeoForgeMod.LAVA_TYPE.value());
+            // CraftBukkit start
+        } else {
+            this.lastLavaContact = null;
+            // CraftBukkit end
         }
 
         this.checkBelowWorld();
@@ -518,14 +_,54 @@
 
     public void lavaHurt() {
         if (!this.fireImmune()) {
-            this.setSecondsOnFire(15);
+            // CraftBukkit start - Fallen in lava TODO: this event spams!
+            if (this instanceof LivingEntity && remainingFireTicks <= 0) {
+                // not on fire yet
+                org.bukkit.block.Block damager = (lastLavaContact == null) ? null : org.bukkit.craftbukkit.v1_20_R3.block.CraftBlock.at(level, lastLavaContact);
+                org.bukkit.entity.Entity damagee = this.getBukkitEntity();
+                org.bukkit.event.entity.EntityCombustEvent combustEvent = new org.bukkit.event.entity.EntityCombustByBlockEvent(damager, damagee, 15);
+                this.level.getCraftServer().getPluginManager().callEvent(combustEvent);
+
+                if (!combustEvent.isCancelled()) {
+                    ketting$setSecondsOnFire$callEvent.set(false);
+                    this.setSecondsOnFire(combustEvent.getDuration());
+                }
+            } else {
+                // This will be called every single tick the entity is in lava, so don't throw an event
+                ketting$setSecondsOnFire$callEvent.set(false);
+                this.setSecondsOnFire(15);
+            }
+            org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.blockDamage = (lastLavaContact) == null ? null : org.bukkit.craftbukkit.v1_20_R3.block.CraftBlock.at(level, lastLavaContact);
             if (this.hurt(this.damageSources().lava(), 4.0F)) {
                 this.playSound(SoundEvents.GENERIC_BURN, 0.4F, 2.0F + this.random.nextFloat() * 0.4F);
             }
+            org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.blockDamage = null;
+            // CraftBukkit end - we also don't throw an event unless the object in lava is living, to save on some event calls
         }
+    }
+
+    //Ketting start
+    public java.util.concurrent.atomic.AtomicBoolean ketting$setSecondsOnFire$callEvent = new java.util.concurrent.atomic.AtomicBoolean(true);
+    @SuppressWarnings("unused") //Ketting - CB compat
+
+    public void setSecondsOnFire(int p_20255_, boolean callEvent) {
+        ketting$setSecondsOnFire$callEvent.set(callEvent);
+        this.setSecondsOnFire(p_20255_);
     }
 
     public void setSecondsOnFire(int p_20255_) {
+        if (ketting$setSecondsOnFire$callEvent.getAndSet(true)) {
+            //Ketting end
+            org.bukkit.event.entity.EntityCombustEvent event = new org.bukkit.event.entity.EntityCombustEvent(this.getBukkitEntity(), p_20255_);
+            this.level.getCraftServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                return;
+            }
+
+            p_20255_ = event.getDuration();
+        }
+        // CraftBukkit end
         int i = p_20255_ * 20;
         if (this instanceof LivingEntity) {
             i = ProtectionEnchantment.getFireAfterDampener((LivingEntity)this, i);
@@ -601,6 +_,7 @@
     }
 
     public void move(MoverType p_19973_, Vec3 p_19974_) {
+        org.bukkit.craftbukkit.v1_20_R3.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
         if (this.noPhysics) {
             this.setPos(this.getX() + p_19974_.x, this.getY() + p_19974_.y, this.getZ() + p_19974_.z);
         } else {
@@ -666,6 +_,28 @@
                     block.updateEntityAfterFallOn(this.level(), this);
                 }
 
+                // CraftBukkit start
+                if (horizontalCollision && getBukkitEntity() instanceof org.bukkit.entity.Vehicle) {
+                    org.bukkit.entity.Vehicle vehicle = (org.bukkit.entity.Vehicle) this.getBukkitEntity();
+                    org.bukkit.block.Block bl = this.level.getWorld().getBlockAt(Mth.floor(this.getX()), Mth.floor(this.getY()), Mth.floor(this.getZ()));
+
+                    if (p_19974_.x > vec3.x) {
+                        bl = bl.getRelative(org.bukkit.block.BlockFace.EAST);
+                    } else if (p_19974_.x < vec3.x) {
+                        bl = bl.getRelative(org.bukkit.block.BlockFace.WEST);
+                    } else if (p_19974_.z > vec3.z) {
+                        bl = bl.getRelative(org.bukkit.block.BlockFace.SOUTH);
+                    } else if (p_19974_.z < vec3.z) {
+                        bl = bl.getRelative(org.bukkit.block.BlockFace.NORTH);
+                    }
+
+                    if (!bl.getType().isAir()) {
+                        org.bukkit.event.vehicle.VehicleBlockCollisionEvent event = new org.bukkit.event.vehicle.VehicleBlockCollisionEvent(vehicle, bl);
+                        level.getCraftServer().getPluginManager().callEvent(event);
+                    }
+                }
+                // CraftBukkit end
+
                 if (this.onGround()) {
                     block.stepOn(this.level(), blockpos, blockstate, this);
                 }
@@ -675,7 +_,7 @@
                     double d1 = vec3.x;
                     double d2 = vec3.y;
                     double d3 = vec3.z;
-                    this.flyDist += (float)(vec3.length() * 0.6);
+                    this.flyDist = (float)((double)this.flyDist + vec3.length() * 0.6D); //additional this.flyDist by whom and why? - Ketting
                     BlockPos blockpos1 = this.getOnPos();
                     BlockState blockstate1 = this.level().getBlockState(blockpos1);
                     boolean flag1 = this.isStateClimbable(blockstate1);
@@ -719,18 +_,19 @@
                         this.setRemainingFireTicks(-this.getFireImmuneTicks());
                     }
 
-                    if (this.wasOnFire && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
+                    if (this.wasOnFire && (this.isInPowderSnow || this.isInWaterRainOrBubble() || this.isInFluidType((fluidType, height) -> this.canFluidExtinguish(fluidType)))) { //additional or after isInWaterRainOrBubble by whom? - Ketting
                         this.playEntityOnFireExtinguishedSound();
                     }
                 }
 
-                if (this.isOnFire() && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
+                if (this.isOnFire() && (this.isInPowderSnow || this.isInWaterRainOrBubble() || this.isInFluidType((fluidType, height) -> this.canFluidExtinguish(fluidType)))) { //additional or after isInWaterRainOrBubble by whom? - Ketting
                     this.setRemainingFireTicks(-this.getFireImmuneTicks());
                 }
 
-                this.level().getProfiler().pop();
+                this.level.getProfiler().pop();
             }
         }
+        org.bukkit.craftbukkit.v1_20_R3.SpigotTimings.entityMoveTimer.stopTiming(); // Spigot
     }
 
     private boolean isStateClimbable(BlockState p_286733_) {
@@ -814,9 +_,7 @@
                 return blockpos;
             } else {
                 BlockState blockstate = this.level().getBlockState(blockpos);
-                return (!((double)p_216987_ <= 0.5) || !blockstate.is(BlockTags.FENCES))
-                        && !blockstate.is(BlockTags.WALLS)
-                        && !(blockstate.getBlock() instanceof FenceGateBlock)
+                return (!((double)p_216987_ <= 0.5) || !blockstate.collisionExtendsVertically(this.level(), blockpos, this))
                     ? blockpos.atY(Mth.floor(this.position.y - (double)p_216987_))
                     : blockpos;
             }
@@ -889,12 +_,13 @@
         boolean flag1 = p_20273_.y != vec3.y;
         boolean flag2 = p_20273_.z != vec3.z;
         boolean flag3 = this.onGround() || flag1 && p_20273_.y < 0.0;
-        if (this.maxUpStep() > 0.0F && flag3 && (flag || flag2)) {
-            Vec3 vec31 = collideBoundingBox(this, new Vec3(p_20273_.x, (double)this.maxUpStep(), p_20273_.z), aabb, this.level(), list);
+        float stepHeight = getStepHeight();
+        if (stepHeight > 0.0F && flag3 && (flag || flag2)) {
+            Vec3 vec31 = collideBoundingBox(this, new Vec3(p_20273_.x, (double)stepHeight, p_20273_.z), aabb, this.level(), list);
             Vec3 vec32 = collideBoundingBox(
-                this, new Vec3(0.0, (double)this.maxUpStep(), 0.0), aabb.expandTowards(p_20273_.x, 0.0, p_20273_.z), this.level(), list
+                this, new Vec3(0.0D, (double)stepHeight, 0.0D), aabb.expandTowards(p_20273_.x, 0.0D, p_20273_.z), this.level(), list
             );
-            if (vec32.y < (double)this.maxUpStep()) {
+            if (vec32.y < (double)stepHeight) {
                 Vec3 vec33 = collideBoundingBox(this, new Vec3(p_20273_.x, 0.0, p_20273_.z), aabb.move(vec32), this.level(), list).add(vec32);
                 if (vec33.horizontalDistanceSqr() > vec31.horizontalDistanceSqr()) {
                     vec31 = vec33;
@@ -978,6 +_,20 @@
         return SoundEvents.GENERIC_SPLASH;
     }
 
+    // CraftBukkit start - Add delegate methods
+    public SoundEvent getSwimSound0() {
+        return getSwimSound();
+    }
+
+    public SoundEvent getSwimSplashSound0() {
+        return getSwimSplashSound();
+    }
+
+    public SoundEvent getSwimHighSpeedSplashSound0() {
+        return getSwimHighSpeedSplashSound();
+    }
+    // CraftBukkit end
+
     protected void checkInsideBlocks() {
         AABB aabb = this.getBoundingBox();
         BlockPos blockpos = BlockPos.containing(aabb.minX + 1.0E-7, aabb.minY + 1.0E-7, aabb.minZ + 1.0E-7);
@@ -1042,19 +_,19 @@
         return !blockstate.is(BlockTags.INSIDE_STEP_SOUND_BLOCKS) && !blockstate.is(BlockTags.COMBINATION_STEP_SOUND_BLOCKS) ? p_278049_ : blockpos;
     }
 
-    protected void playCombinationStepSounds(BlockState p_277472_, BlockState p_277630_) {
-        SoundType soundtype = p_277472_.getSoundType();
+    protected void playCombinationStepSounds(BlockState p_277472_, BlockState p_277630_, BlockPos primaryPos, BlockPos secondaryPos) {
+        SoundType soundtype = p_277472_.getSoundType(this.level, primaryPos, this);
         this.playSound(soundtype.getStepSound(), soundtype.getVolume() * 0.15F, soundtype.getPitch());
-        this.playMuffledStepSound(p_277630_);
+        this.playMuffledStepSound(p_277630_, secondaryPos);
     }
 
-    protected void playMuffledStepSound(BlockState p_283110_) {
-        SoundType soundtype = p_283110_.getSoundType();
+    protected void playMuffledStepSound(BlockState p_283110_, BlockPos pos) {
+        SoundType soundtype = p_283110_.getSoundType(this.level, pos, this);
         this.playSound(soundtype.getStepSound(), soundtype.getVolume() * 0.05F, soundtype.getPitch() * 0.8F);
     }
 
     protected void playStepSound(BlockPos p_20135_, BlockState p_20136_) {
-        SoundType soundtype = p_20136_.getSoundType();
+        SoundType soundtype = p_20136_.getSoundType(this.level, p_20135_, this);
         this.playSound(soundtype.getStepSound(), soundtype.getVolume() * 0.15F, soundtype.getPitch());
     }
 
@@ -1192,20 +_,23 @@
 
     public void updateSwimming() {
         if (this.isSwimming()) {
-            this.setSwimming(this.isSprinting() && this.isInWater() && !this.isPassenger());
+            this.setSwimming(this.isSprinting() && (this.isInWater() || this.isInFluidType((fluidType, height) -> this.canSwimInFluidType(fluidType))) && !this.isPassenger());
         } else {
             this.setSwimming(
-                this.isSprinting() && this.isUnderWater() && !this.isPassenger() && this.level().getFluidState(this.blockPosition).is(FluidTags.WATER)
+                this.isSprinting() && (this.isUnderWater() || this.canStartSwimming()) && !this.isPassenger()
             );
         }
     }
 
     protected boolean updateInWaterStateAndDoFluidPushing() {
         this.fluidHeight.clear();
+        this.forgeFluidTypeHeight.clear();
         this.updateInWaterStateAndDoWaterCurrentPushing();
-        double d0 = this.level().dimensionType().ultraWarm() ? 0.007 : 0.0023333333333333335;
-        boolean flag = this.updateFluidHeightAndDoFluidPushing(FluidTags.LAVA, d0);
-        return this.isInWater() || flag;
+        if (this.isInFluidType() && !(this.getVehicle() instanceof Boat)) {
+            this.fallDistance *= this.forgeFluidTypeHeight.object2DoubleEntrySet().stream().filter(e -> !e.getKey().isAir() && !e.getKey().isVanilla()).map(e -> this.getFluidFallDistanceModifier(e.getKey())).min(Float::compare).orElse(1F);
+            if (this.isInFluidType((fluidType, height) -> !fluidType.isAir() && !fluidType.isVanilla() && this.canFluidExtinguish(fluidType))) this.clearFire();
+        }
+        return this.isInFluidType();
     }
 
     void updateInWaterStateAndDoWaterCurrentPushing() {
@@ -1231,6 +_,7 @@
     private void updateFluidOnEyes() {
         this.wasEyeInWater = this.isEyeInFluid(FluidTags.WATER);
         this.fluidOnEyes.clear();
+        this.forgeFluidTypeOnEyes = net.neoforged.neoforge.common.NeoForgeMod.EMPTY_TYPE.value();
         double d0 = this.getEyeY() - 0.11111111F;
         Entity entity = this.getVehicle();
         if (entity instanceof Boat boat && !boat.isUnderWater() && boat.getBoundingBox().maxY >= d0 && boat.getBoundingBox().minY <= d0) {
@@ -1241,7 +_,7 @@
         FluidState fluidstate = this.level().getFluidState(blockpos);
         double d1 = (double)((float)blockpos.getY() + fluidstate.getHeight(this.level(), blockpos));
         if (d1 > d0) {
-            fluidstate.getTags().forEach(this.fluidOnEyes::add);
+            this.forgeFluidTypeOnEyes = fluidstate.getFluidType();
         }
     }
 
@@ -1286,12 +_,13 @@
     }
 
     public boolean canSpawnSprintParticle() {
-        return this.isSprinting() && !this.isInWater() && !this.isSpectator() && !this.isCrouching() && !this.isInLava() && this.isAlive();
+        return this.isSprinting() && !this.isInWater() && !this.isSpectator() && !this.isCrouching() && !this.isInLava() && this.isAlive() && !this.isInFluidType();
     }
 
     protected void spawnSprintParticle() {
         BlockPos blockpos = this.getOnPosLegacy();
         BlockState blockstate = this.level().getBlockState(blockpos);
+        if(!blockstate.addRunningEffects(level, blockpos, this))
         if (blockstate.getRenderShape() != RenderShape.INVISIBLE) {
             Vec3 vec3 = this.getDeltaMovement();
             BlockPos blockpos1 = this.blockPosition();
@@ -1305,16 +_,19 @@
                 d1 = Mth.clamp(d1, (double)blockpos.getZ(), (double)blockpos.getZ() + 1.0);
             }
 
-            this.level().addParticle(new BlockParticleOption(ParticleTypes.BLOCK, blockstate), d0, this.getY() + 0.1, d1, vec3.x * -4.0, 1.5, vec3.z * -4.0);
+            this.level().addParticle(new BlockParticleOption(ParticleTypes.BLOCK, blockstate).setPos(blockpos), d0, this.getY() + 0.1, d1, vec3.x * -4.0, 1.5, vec3.z * -4.0);
         }
     }
 
+    @Deprecated // Forge: Use isEyeInFluidType instead
     public boolean isEyeInFluid(TagKey<Fluid> p_204030_) {
+        if (p_204030_ == FluidTags.WATER) return this.isEyeInFluidType(net.neoforged.neoforge.common.NeoForgeMod.WATER_TYPE.value());
+        else if (p_204030_ == FluidTags.LAVA) return this.isEyeInFluidType(net.neoforged.neoforge.common.NeoForgeMod.LAVA_TYPE.value());
         return this.fluidOnEyes.contains(p_204030_);
     }
 
     public boolean isInLava() {
-        return !this.firstTick && this.fluidHeight.getDouble(FluidTags.LAVA) > 0.0;
+        return !this.firstTick && this.forgeFluidTypeHeight.getDouble(net.neoforged.neoforge.common.NeoForgeMod.LAVA_TYPE.value()) > 0.0D;
     }
 
     public void moveRelative(float p_19921_, Vec3 p_19922_) {
@@ -1540,6 +_,12 @@
         return false;
     }
 
+    // CraftBukkit start - collidable API
+    public boolean canCollideWithBukkit(Entity entity) {
+        return isPushable();
+    }
+    // CraftBukkit end
+
     public void awardKillScore(Entity p_19953_, int p_19954_, DamageSource p_19955_) {
         if (p_19953_ instanceof ServerPlayer) {
             CriteriaTriggers.ENTITY_KILLED_PLAYER.trigger((ServerPlayer)p_19953_, this, p_19955_);
@@ -1564,8 +_,20 @@
         return p_19883_ < d0 * d0;
     }
 
+    // Ketting start
+    private boolean saveAsPassenger_includeAll;
+    public void prepareSaveAsPassenger(boolean includeAll){
+        this.saveAsPassenger_includeAll = includeAll;
+    }
+    public boolean saveAsPassenger(CompoundTag p_20087_, boolean includeAll){
+        prepareSaveAsPassenger(includeAll);
+        return saveAsPassenger(p_20087_);
+    }
+    //Ketting end
+
     public boolean saveAsPassenger(CompoundTag p_20087_) {
         if (this.removalReason != null && !this.removalReason.shouldSave()) {
+            this.saveWithoutId_includeAll = true; //Ketting reset flag
             return false;
         } else {
             String s = this.getEncodeId();
@@ -1573,7 +_,9 @@
                 return false;
             } else {
                 p_20087_.putString("id", s);
+                this.prepareSaveWithoutId(saveAsPassenger_includeAll); // Ketting/CraftBukkit - pass on includeAll
                 this.saveWithoutId(p_20087_);
+                this.saveWithoutId_includeAll = true; //Ketting reset flag
                 return true;
             }
         }
@@ -1583,16 +_,41 @@
         return this.isPassenger() ? false : this.saveAsPassenger(p_20224_);
     }
 
+    // Ketting start
+    private boolean saveWithoutId_includeAll;
+    public void prepareSaveWithoutId(boolean includeAll){
+        this.saveWithoutId_includeAll = includeAll;
+    }
+    public CompoundTag saveWithoutId(CompoundTag p_20241_, boolean includeAll){
+        prepareSaveWithoutId(includeAll);
+        return saveWithoutId(p_20241_);
+    }
+    //Ketting end
+
     public CompoundTag saveWithoutId(CompoundTag p_20241_) {
         try {
+            if (saveWithoutId_includeAll){ //CraftBukkit - selectively save position
             if (this.vehicle != null) {
                 p_20241_.put("Pos", this.newDoubleList(this.vehicle.getX(), this.getY(), this.vehicle.getZ()));
             } else {
                 p_20241_.put("Pos", this.newDoubleList(this.getX(), this.getY(), this.getZ()));
             }
+            } //CraftBukkit
 
             Vec3 vec3 = this.getDeltaMovement();
             p_20241_.put("Motion", this.newDoubleList(vec3.x, vec3.y, vec3.z));
+
+            // CraftBukkit start - Checking for NaN pitch/yaw and resetting to zero
+            // TODO: make sure this is the best way to address this.
+            if (Float.isNaN(this.yRot)) {
+                this.yRot = 0;
+            }
+
+            if (Float.isNaN(this.xRot)) {
+                this.xRot = 0;
+            }
+            // CraftBukkit end
+
             p_20241_.put("Rotation", this.newFloatList(this.getYRot(), this.getXRot()));
             p_20241_.putFloat("FallDistance", this.fallDistance);
             p_20241_.putShort("Fire", (short)this.remainingFireTicks);
@@ -1600,7 +_,29 @@
             p_20241_.putBoolean("OnGround", this.onGround());
             p_20241_.putBoolean("Invulnerable", this.invulnerable);
             p_20241_.putInt("PortalCooldown", this.portalCooldown);
+            if (saveWithoutId_includeAll) { // CraftBukkit - selectively save uuid and world
             p_20241_.putUUID("UUID", this.getUUID());
+                // CraftBukkit start
+                // PAIL: Check above UUID reads 1.8 properly, ie: UUIDMost / UUIDLeast
+                p_20241_.putLong("WorldUUIDLeast", this.level.getWorld().getUID().getLeastSignificantBits());
+                p_20241_.putLong("WorldUUIDMost", this.level.getWorld().getUID().getMostSignificantBits());
+            } //CraftBukkit
+            p_20241_.putInt("Bukkit.updateLevel", CURRENT_LEVEL);
+            if (!this.persist) {
+                p_20241_.putBoolean("Bukkit.persist", this.persist);
+            }
+            if (!this.visibleByDefault) {
+                p_20241_.putBoolean("Bukkit.visibleByDefault", this.visibleByDefault);
+            }
+            if (this.persistentInvisibility) {
+                p_20241_.putBoolean("Bukkit.invisible", this.persistentInvisibility);
+            }
+            // SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
+            if (maxAirTicks != getDefaultMaxAirSupply()) {
+                p_20241_.putInt("Bukkit.MaxAirSupply", getMaxAirSupply());
+            }
+            p_20241_.putInt("Spigot.ticksLived", this.tickCount);
+            // CraftBukkit end
             Component component = this.getCustomName();
             if (component != null) {
                 p_20241_.putString("CustomName", Component.Serializer.toJson(component));
@@ -1631,6 +_,8 @@
                 p_20241_.putBoolean("HasVisualFire", this.hasVisualFire);
             }
 
+            p_20241_.putBoolean("CanUpdate", canUpdate);
+
             if (!this.tags.isEmpty()) {
                 ListTag listtag = new ListTag();
 
@@ -1641,12 +_,18 @@
                 p_20241_.put("Tags", listtag);
             }
 
+            CompoundTag attachments = serializeAttachments();
+            if (attachments != null) p_20241_.put(ATTACHMENTS_NBT_KEY, attachments);
+            if (persistentData != null) p_20241_.put("NeoForgeData", persistentData.copy());
+
+            this.prepareAddAdditionalSaveData(saveWithoutId_includeAll); // Ketting - make CB patch more mixin friendly - CraftBukkit - selectively save uuid and world
             this.addAdditionalSaveData(p_20241_);
             if (this.isVehicle()) {
                 ListTag listtag1 = new ListTag();
 
                 for(Entity entity : this.getPassengers()) {
                     CompoundTag compoundtag = new CompoundTag();
+                    entity.prepareSaveAsPassenger(saveWithoutId_includeAll);  // Ketting - make CB patch more mixin friendly - CraftBukkit - selectively save uuid and world
                     if (entity.saveAsPassenger(compoundtag)) {
                         listtag1.add(compoundtag);
                     }
@@ -1657,8 +_,15 @@
                 }
             }
 
+            saveWithoutId_includeAll = true; //Ketting reset value to default
+            // CraftBukkit start - stores eventually existing bukkit values
+            if (this.bukkitEntity != null) {
+                this.bukkitEntity.storeBukkitValues(p_20241_);
+            }
+            // CraftBukkit end
             return p_20241_;
         } catch (Throwable throwable) {
+            saveWithoutId_includeAll = true; //Ketting reset value to default
             CrashReport crashreport = CrashReport.forThrowable(throwable, "Saving entity NBT");
             CrashReportCategory crashreportcategory = crashreport.addCategory("Entity being saved");
             this.fillCrashReportCategory(crashreportcategory);
@@ -1721,6 +_,9 @@
                 this.setGlowingTag(p_20259_.getBoolean("Glowing"));
                 this.setTicksFrozen(p_20259_.getInt("TicksFrozen"));
                 this.hasVisualFire = p_20259_.getBoolean("HasVisualFire");
+                if (p_20259_.contains("NeoForgeData", 10)) persistentData = p_20259_.getCompound("NeoForgeData");
+                if (p_20259_.contains("CanUpdate", 99)) this.canUpdate(p_20259_.getBoolean("CanUpdate"));
+                if (p_20259_.contains(ATTACHMENTS_NBT_KEY, net.minecraft.nbt.Tag.TAG_COMPOUND)) deserializeAttachments(p_20259_.getCompound(ATTACHMENTS_NBT_KEY));
                 if (p_20259_.contains("Tags", 9)) {
                     this.tags.clear();
                     ListTag listtag3 = p_20259_.getList("Tags", 8);
@@ -1738,6 +_,49 @@
             } else {
                 throw new IllegalStateException("Entity has invalid rotation");
             }
+
+            // CraftBukkit start
+            // Spigot start
+            if (this instanceof LivingEntity) {
+                this.tickCount = p_20259_.getInt("Spigot.ticksLived");
+            }
+            // Spigot end
+            this.persist = !p_20259_.contains("Bukkit.persist") || p_20259_.getBoolean("Bukkit.persist");
+            this.visibleByDefault = !p_20259_.contains("Bukkit.visibleByDefault") || p_20259_.getBoolean("Bukkit.visibleByDefault");
+            // SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
+            if (p_20259_.contains("Bukkit.MaxAirSupply")) {
+                maxAirTicks = p_20259_.getInt("Bukkit.MaxAirSupply");
+            }
+            // CraftBukkit end
+
+            // CraftBukkit start - Reset world
+            if (this instanceof ServerPlayer) {
+                org.bukkit.Server server = org.bukkit.Bukkit.getServer();
+                org.bukkit.World bworld = null;
+
+                // TODO: Remove World related checks, replaced with WorldUID
+                String worldName = p_20259_.getString("world");
+
+                if (p_20259_.contains("WorldUUIDMost") && p_20259_.contains("WorldUUIDLeast")) {
+                    UUID uid = new UUID(p_20259_.getLong("WorldUUIDMost"), p_20259_.getLong("WorldUUIDLeast"));
+                    bworld = server.getWorld(uid);
+                } else {
+                    bworld = server.getWorld(worldName);
+                }
+
+                if (bworld == null) {
+                    bworld = ((org.bukkit.craftbukkit.v1_20_R3.CraftServer) server).getServer().getLevel(Level.OVERWORLD).getWorld();
+                }
+
+                this.setLevel(bworld == null ? null : ((org.bukkit.craftbukkit.v1_20_R3.CraftWorld) bworld).getHandle());
+            }
+            this.getBukkitEntity().readBukkitValues(p_20259_);
+            if (p_20259_.contains("Bukkit.invisible")) {
+                boolean bukkitInvisible = p_20259_.getBoolean("Bukkit.invisible");
+                this.setInvisible(bukkitInvisible);
+                this.persistentInvisibility = bukkitInvisible;
+            }
+            // CraftBukkit end
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.forThrowable(throwable, "Loading entity NBT");
             CrashReportCategory crashreportcategory = crashreport.addCategory("Entity being loaded");
@@ -1759,6 +_,21 @@
 
     protected abstract void readAdditionalSaveData(CompoundTag p_20052_);
 
+    //Ketting start
+    protected boolean addAdditionalSaveData_includeAll = true;
+    protected void prepareAddAdditionalSaveData(boolean includeAll){
+        this.addAdditionalSaveData_includeAll = includeAll;
+    }
+    protected void resetAddAdditionalSaveData_includeAll(){
+        this.addAdditionalSaveData_includeAll = true;
+    }
+    protected void addAdditionalSaveData(CompoundTag p_20139_, boolean includeAll){
+        prepareAddAdditionalSaveData(includeAll);
+        addAdditionalSaveData(p_20139_);
+        resetAddAdditionalSaveData_includeAll();
+    }
+    //Ketting end
+
     protected abstract void addAdditionalSaveData(CompoundTag p_20139_);
 
     protected ListTag newDoubleList(double... p_20064_) {
@@ -1803,8 +_,23 @@
         } else if (this.level().isClientSide) {
             return null;
         } else {
+            // CraftBukkit start - Capture drops for death event
+            if (this instanceof LivingEntity && !((LivingEntity) this).forceDrops) {
+                ((LivingEntity) this).drops.add(org.bukkit.craftbukkit.v1_20_R3.inventory.CraftItemStack.asBukkitCopy(p_19985_));
+                return null;
+            }
+            // CraftBukkit end
             ItemEntity itementity = new ItemEntity(this.level(), this.getX(), this.getY() + (double)p_19986_, this.getZ(), p_19985_);
             itementity.setDefaultPickUpDelay();
+            // CraftBukkit start
+            org.bukkit.event.entity.EntityDropItemEvent event = new org.bukkit.event.entity.EntityDropItemEvent(this.getBukkitEntity(), (org.bukkit.entity.Item) itementity.getBukkitEntity());
+            org.bukkit.Bukkit.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return null;
+            }
+            // CraftBukkit end
+            if (captureDrops() != null) captureDrops().add(itementity);
+            else
             this.level().addFreshEntity(itementity);
             return itementity;
         }
@@ -1851,6 +_,7 @@
 
     public void rideTick() {
         this.setDeltaMovement(Vec3.ZERO);
+        if (canUpdate())
         this.tick();
         if (this.isPassenger()) {
             this.getVehicle().positionRider(this);
@@ -1908,7 +_,30 @@
                 }
             }
 
+        if (!net.neoforged.neoforge.event.EventHooks.canMountEntity(this, p_19966_, true)) return false;
             if (p_19967_ || this.canRide(p_19966_) && p_19966_.canAddPassenger(this)) {
+                // CraftBukkit start
+                if (p_19966_.getBukkitEntity() instanceof org.bukkit.entity.Vehicle && this.getBukkitEntity() instanceof org.bukkit.entity.LivingEntity) {
+                    org.bukkit.event.vehicle.VehicleEnterEvent event = new org.bukkit.event.vehicle.VehicleEnterEvent((org.bukkit.entity.Vehicle) p_19966_.getBukkitEntity(), this.getBukkitEntity());
+                    // Suppress during worldgen
+                    if (this.valid) {
+                        org.bukkit.Bukkit.getPluginManager().callEvent(event);
+                    }
+                    if (event.isCancelled()) {
+                        return false;
+                    }
+                }
+                // CraftBukkit end
+                // Spigot start
+                org.spigotmc.event.entity.EntityMountEvent event = new org.spigotmc.event.entity.EntityMountEvent(this.getBukkitEntity(), p_19966_.getBukkitEntity());
+                // Suppress during worldgen
+                if (this.valid) {
+                    org.bukkit.Bukkit.getPluginManager().callEvent(event);
+                }
+                if (event.isCancelled()) {
+                    return false;
+                }
+                // Spigot end
                 if (this.isPassenger()) {
                     this.stopRiding();
                 }
@@ -1939,8 +_,10 @@
     public void removeVehicle() {
         if (this.vehicle != null) {
             Entity entity = this.vehicle;
+            if (!net.neoforged.neoforge.event.EventHooks.canMountEntity(this, entity, false)) return;
             this.vehicle = null;
             entity.removePassenger(this);
+            if (!entity.ketting$removePassenger$returnValue) this.vehicle = entity; // CraftBukkit
         }
     }
 
@@ -1969,10 +_,42 @@
         }
     }
 
+    public boolean ketting$removePassenger$returnValue = false;
     protected void removePassenger(Entity p_20352_) {
         if (p_20352_.getVehicle() == this) {
             throw new IllegalStateException("Use x.stopRiding(y), not y.removePassenger(x)");
         } else {
+            // CraftBukkit start
+            org.bukkit.craftbukkit.v1_20_R3.entity.CraftEntity craft = (org.bukkit.craftbukkit.v1_20_R3.entity.CraftEntity) p_20352_.getBukkitEntity().getVehicle();
+            Entity orig = craft == null ? null : craft.getHandle();
+            if (getBukkitEntity() instanceof org.bukkit.entity.Vehicle && p_20352_.getBukkitEntity() instanceof org.bukkit.entity.LivingEntity) {
+                org.bukkit.event.vehicle.VehicleExitEvent event = new org.bukkit.event.vehicle.VehicleExitEvent(
+                        (org.bukkit.entity.Vehicle) getBukkitEntity(),
+                        (org.bukkit.entity.LivingEntity) p_20352_.getBukkitEntity()
+                );
+                // Suppress during worldgen
+                if (this.valid) {
+                    org.bukkit.Bukkit.getPluginManager().callEvent(event);
+                }
+                org.bukkit.craftbukkit.v1_20_R3.entity.CraftEntity craftn = (org.bukkit.craftbukkit.v1_20_R3.entity.CraftEntity) p_20352_.getBukkitEntity().getVehicle();
+                Entity n = craftn == null ? null : craftn.getHandle();
+                if (event.isCancelled() || n != orig) {
+                    ketting$removePassenger$returnValue = false;
+                    return;
+                }
+            }
+            // CraftBukkit end
+            // Spigot start
+            org.spigotmc.event.entity.EntityDismountEvent event = new org.spigotmc.event.entity.EntityDismountEvent(p_20352_.getBukkitEntity(), this.getBukkitEntity());
+            // Suppress during worldgen
+            if (this.valid) {
+                org.bukkit.Bukkit.getPluginManager().callEvent(event);
+            }
+            if (event.isCancelled()) {
+                ketting$removePassenger$returnValue = false;
+                return;
+            }
+            // Spigot end
             if (this.passengers.size() == 1 && this.passengers.get(0) == p_20352_) {
                 this.passengers = ImmutableList.of();
             } else {
@@ -1982,12 +_,15 @@
             p_20352_.boardingCooldown = 60;
             this.gameEvent(GameEvent.ENTITY_DISMOUNT, p_20352_);
         }
+        ketting$removePassenger$returnValue = true;
     }
 
     protected boolean canAddPassenger(Entity p_20354_) {
         return this.passengers.isEmpty();
     }
 
+    /** @deprecated Forge: Use {@link #canBeRiddenUnderFluidType(net.neoforged.neoforge.fluids.FluidType, Entity) rider sensitive version} */
+    @Deprecated
     protected boolean couldAcceptPassenger() {
         return true;
     }
@@ -2066,13 +_,19 @@
             ServerLevel serverlevel = (ServerLevel)this.level();
             if (this.isInsidePortal) {
                 MinecraftServer minecraftserver = serverlevel.getServer();
-                ResourceKey<Level> resourcekey = this.level().dimension() == Level.NETHER ? Level.OVERWORLD : Level.NETHER;
+                ResourceKey<Level> resourcekey = this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER ? Level.OVERWORLD : Level.NETHER; // CraftBukkit
                 ServerLevel serverlevel1 = minecraftserver.getLevel(resourcekey);
-                if (serverlevel1 != null && minecraftserver.isNetherEnabled() && !this.isPassenger() && this.portalTime++ >= i) {
+                if (!this.isPassenger() && this.portalTime++ >= i) { // CraftBukkit
                     this.level().getProfiler().push("portal");
                     this.portalTime = i;
                     this.setPortalCooldown();
-                    this.changeDimension(serverlevel1);
+                    // CraftBukkit start
+                    if (this instanceof ServerPlayer) {
+                        ((ServerPlayer) this).changeDimension(serverlevel1, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.NETHER_PORTAL);
+                    } else {
+                        this.changeDimension(serverlevel1);
+                    }
+                    // CraftBukkit end
                     this.level().getProfiler().pop();
                 }
 
@@ -2193,10 +_,17 @@
     }
 
     public boolean isVisuallyCrawling() {
-        return this.isVisuallySwimming() && !this.isInWater();
+        return this.isVisuallySwimming() && !this.isInWater() && !this.isInFluidType((fluidType, height) -> this.canSwimInFluidType(fluidType));
     }
 
     public void setSwimming(boolean p_20283_) {
+        // CraftBukkit start
+        if (valid && this.isSwimming() != p_20283_ && this instanceof LivingEntity) {
+            if (org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.callToggleSwimEvent((LivingEntity) this, p_20283_).isCancelled()) {
+                return;
+            }
+        }
+        // CraftBukkit end
         this.setSharedFlag(4, p_20283_);
     }
 
@@ -2246,8 +_,12 @@
         return this.getTeam() != null ? this.getTeam().isAlliedTo(p_20032_) : false;
     }
 
+    // CraftBukkit - start
     public void setInvisible(boolean p_20304_) {
-        this.setSharedFlag(5, p_20304_);
+        if (!this.persistentInvisibility) { // Prevent Minecraft from removing our invisibility flag
+            this.setSharedFlag(5, p_20304_);
+        }
+        // CraftBukkit - end
     }
 
     protected boolean getSharedFlag(int p_20292_) {
@@ -2264,7 +_,7 @@
     }
 
     public int getMaxAirSupply() {
-        return 300;
+        return maxAirTicks; // CraftBukkit - SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
     }
 
     public int getAirSupply() {
@@ -2272,7 +_,18 @@
     }
 
     public void setAirSupply(int p_20302_) {
-        this.entityData.set(DATA_AIR_SUPPLY_ID, p_20302_);
+        // CraftBukkit start
+        org.bukkit.event.entity.EntityAirChangeEvent event = new org.bukkit.event.entity.EntityAirChangeEvent(this.getBukkitEntity(), p_20302_);
+        // Suppress during worldgen
+        if (this.valid) {
+            event.getEntity().getServer().getPluginManager().callEvent(event);
+        }
+        if (event.isCancelled() && this.getAirSupply() != p_20302_) {
+            this.entityData.markDirty(Entity.DATA_AIR_SUPPLY_ID);
+            return;
+        }
+        this.entityData.set(Entity.DATA_AIR_SUPPLY_ID, event.getAmount());
+        // CraftBukkit end
     }
 
     public int getTicksFrozen() {
@@ -2298,11 +_,42 @@
 
     public void thunderHit(ServerLevel p_19927_, LightningBolt p_19928_) {
         this.setRemainingFireTicks(this.remainingFireTicks + 1);
+        // CraftBukkit start
+        final org.bukkit.entity.Entity thisBukkitEntity = this.getBukkitEntity();
+        final org.bukkit.entity.Entity stormBukkitEntity = p_19928_.getBukkitEntity();
+        final org.bukkit.plugin.PluginManager pluginManager = org.bukkit.Bukkit.getPluginManager();
+        // CraftBukkit end
+
         if (this.remainingFireTicks == 0) {
-            this.setSecondsOnFire(8);
-        }
-
-        this.hurt(this.damageSources().lightningBolt(), 5.0F);
+            // CraftBukkit start - Call a combust event when lightning strikes
+            org.bukkit.event.entity.EntityCombustByEntityEvent entityCombustEvent = new org.bukkit.event.entity.EntityCombustByEntityEvent(stormBukkitEntity, thisBukkitEntity, 8);
+            pluginManager.callEvent(entityCombustEvent);
+            if (!entityCombustEvent.isCancelled()) {
+                ketting$setSecondsOnFire$callEvent.set(false);
+                this.setSecondsOnFire(entityCombustEvent.getDuration());
+            }
+            // CraftBukkit end
+        }
+
+        // CraftBukkit start
+        if (thisBukkitEntity instanceof org.bukkit.entity.Hanging) {
+            org.bukkit.event.hanging.HangingBreakByEntityEvent hangingEvent = new org.bukkit.event.hanging.HangingBreakByEntityEvent((org.bukkit.entity.Hanging) thisBukkitEntity, stormBukkitEntity);
+            pluginManager.callEvent(hangingEvent);
+
+            if (hangingEvent.isCancelled()) {
+                return;
+            }
+        }
+
+        if (this.fireImmune()) {
+            return;
+        }
+        org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.entityDamage = p_19928_;
+        if (!this.hurt(this.damageSources().lightningBolt(), p_19928_.getDamage())) {
+            org.bukkit.craftbukkit.v1_20_R3.event.CraftEventFactory.entityDamage = null;
+            return;
+        }
+        // CraftBukkit end
     }
 
     public void onAboveBubbleCol(boolean p_20313_) {
@@ -2397,7 +_,7 @@
     }
 
     protected Component getTypeName() {
-        return this.type.getDescription();
+        return this.getType().getDescription(); // Forge: Use getter to allow overriding by mods
     }
 
     public boolean is(Entity p_20356_) {
@@ -2478,34 +_,87 @@
         this.portalEntrancePos = p_20362_.portalEntrancePos;
     }
 
+    //Ketting start - bukkit function
+    private Vec3 teleportTo$location;
+    @Nullable
+    public Entity teleportTo(ServerLevel worldserver, Vec3 location) {
+        try {
+            this.teleportTo$location = location;
+            return this.changeDimension(worldserver, worldserver.getPortalForcer());
+        } finally {
+            this.teleportTo$location = null;
+        }
+    }
+
     @Nullable
     public Entity changeDimension(ServerLevel p_20118_) {
+        return this.changeDimension(p_20118_, p_20118_.getPortalForcer());
+    }
+    @Nullable
+    public Entity changeDimension(ServerLevel p_20118_, net.neoforged.neoforge.common.util.ITeleporter teleporter) {
+        if (!net.neoforged.neoforge.common.CommonHooks.onTravelToDimension(this, p_20118_.dimension())) return null;
         if (this.level() instanceof ServerLevel && !this.isRemoved()) {
             this.level().getProfiler().push("changeDimension");
-            this.unRide();
+            // CraftBukkit start
+            if (teleporter == null) teleporter = p_20118_.getPortalForcer();
+            // this.unRide();
+            if (p_20118_ == null) {
+                return null;
+            }
+            // CraftBukkit end
             this.level().getProfiler().push("reposition");
-            PortalInfo portalinfo = this.findDimensionEntryPoint(p_20118_);
+            PortalInfo portalinfo = teleporter.getPortalInfo(this, p_20118_, this::findDimensionEntryPoint);
             if (portalinfo == null) {
                 return null;
             } else {
-                this.level().getProfiler().popPush("reloading");
-                Entity entity = this.getType().create(p_20118_);
-                if (entity != null) {
-                    entity.restoreFrom(this);
-                    entity.moveTo(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z, portalinfo.yRot, entity.getXRot());
-                    entity.setDeltaMovement(portalinfo.speed);
-                    p_20118_.addDuringTeleport(entity);
-                    if (p_20118_.dimension() == Level.END) {
-                        ServerLevel.makeObsidianPlatform(p_20118_);
-                    }
+                // CraftBukkit start
+                p_20118_ = portalinfo.world;
+                if (p_20118_ == level) {
+                    // SPIGOT-6782: Just move the entity if a plugin changed the world to the one the entity is already in
+                    moveTo(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z, portalinfo.yRot, portalinfo.xRot);
+                    setDeltaMovement(portalinfo.speed);
+                    return this;
                 }
+                this.unRide();
+                // CraftBukkit end
+
+                final ServerLevel finalLevel = p_20118_; //Ketting
+
+                Entity transportedEntity = teleporter.placeEntity(this, (ServerLevel) this.level, finalLevel, this.yRot, spawnPortal -> { //Forge: Start vanilla logic
+                    this.level().getProfiler().popPush("reloading");
+                    Entity entity = this.getType().create(finalLevel);
+                    if (entity != null) {
+                        entity.restoreFrom(this);
+                        entity.moveTo(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z, portalinfo.yRot, entity.getXRot());
+                        entity.setDeltaMovement(portalinfo.speed);
+                        // CraftBukkit start - Don't spawn the new entity if the current entity isn't spawned
+                        if (this.inWorld) {
+                            finalLevel.addDuringTeleport(entity);
+                            if (spawnPortal && finalLevel.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.END) { // CraftBukkit
+                                ServerLevel.ketting$makeObsidianPlatform$entity.set(this);
+                                ServerLevel.makeObsidianPlatform(finalLevel);
+                            }
+                        }
+                        // CraftBukkit end
+
+                        // CraftBukkit start - Forward the org.bukkit.craftbukkit.v1_20_R3.entity.CraftEntity to the new entity
+                        this.getBukkitEntity().setHandle(entity);
+                        entity.bukkitEntity = this.getBukkitEntity();
+
+                        if (this instanceof Mob) {
+                            ((Mob) this).dropLeash(true, false); // Unleash to prevent duping of leads.
+                        }
+                        // CraftBukkit end
+                    }
+                    return entity;
+                }); //Forge: End vanilla logic
 
                 this.removeAfterChangingDimensions();
                 this.level().getProfiler().pop();
                 ((ServerLevel)this.level()).resetEmptyTime();
-                p_20118_.resetEmptyTime();
+                finalLevel.resetEmptyTime();
                 this.level().getProfiler().pop();
-                return entity;
+                return transportedEntity;
             }
         } else {
             return null;
@@ -2518,44 +_,53 @@
 
     @Nullable
     protected PortalInfo findDimensionEntryPoint(ServerLevel p_19923_) {
-        boolean flag = this.level().dimension() == Level.END && p_19923_.dimension() == Level.OVERWORLD;
-        boolean flag1 = p_19923_.dimension() == Level.END;
+        // CraftBukkit start
+        if (p_19923_ == null) {
+            return null;
+        }
+        boolean flag = this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.END && p_19923_.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.OVERWORLD; // fromEndToOverworld
+        boolean flag1 = p_19923_.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.END; // targetIsEnd
+        // CraftBukkit end
         if (!flag && !flag1) {
-            boolean flag2 = p_19923_.dimension() == Level.NETHER;
-            if (this.level().dimension() != Level.NETHER && !flag2) {
+            boolean flag2 = p_19923_.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER; // CraftBukkit
+            if (this.level().getTypeKey() != net.minecraft.world.level.dimension.LevelStem.NETHER && !flag2) { // CraftBukkit
                 return null;
             } else {
                 WorldBorder worldborder = p_19923_.getWorldBorder();
                 double d0 = DimensionType.getTeleportationScale(this.level().dimensionType(), p_19923_.dimensionType());
                 BlockPos blockpos1 = worldborder.clampToBounds(this.getX() * d0, this.getY(), this.getZ() * d0);
-                return this.getExitPortal(p_19923_, blockpos1, flag2, worldborder)
-                    .map(
-                        p_258249_ -> {
-                            BlockState blockstate = this.level().getBlockState(this.portalEntrancePos);
-                            Direction.Axis direction$axis;
-                            Vec3 vec3;
-                            if (blockstate.hasProperty(BlockStateProperties.HORIZONTAL_AXIS)) {
-                                direction$axis = blockstate.getValue(BlockStateProperties.HORIZONTAL_AXIS);
-                                BlockUtil.FoundRectangle blockutil$foundrectangle = BlockUtil.getLargestRectangleAround(
-                                    this.portalEntrancePos,
-                                    direction$axis,
-                                    21,
-                                    Direction.Axis.Y,
-                                    21,
-                                    p_284700_ -> this.level().getBlockState(p_284700_) == blockstate
-                                );
-                                vec3 = this.getRelativePortalPosition(direction$axis, blockutil$foundrectangle);
-                            } else {
-                                direction$axis = Direction.Axis.X;
-                                vec3 = new Vec3(0.5, 0.0, 0.0);
-                            }
-        
-                            return PortalShape.createPortalInfo(
-                                p_19923_, p_258249_, direction$axis, vec3, this, this.getDeltaMovement(), this.getYRot(), this.getXRot()
-                            );
-                        }
-                    )
-                    .orElse(null);
+                // CraftBukkit start
+                org.bukkit.craftbukkit.v1_20_R3.event.CraftPortalEvent event = callPortalEvent(this, p_19923_, new Vec3(blockpos1.getX(), blockpos1.getY(), blockpos1.getZ()), org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.NETHER_PORTAL, flag2 ? 16 : 128, 16);
+                if (event == null) {
+                    return null;
+                }
+                final ServerLevel worldserverFinal = p_19923_ = ((org.bukkit.craftbukkit.v1_20_R3.CraftWorld) event.getTo().getWorld()).getHandle();
+                worldborder = worldserverFinal.getWorldBorder();
+                blockpos1 = worldborder.clampToBounds(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ());
+
+                return this.getExitPortal(p_19923_, blockpos1, flag2, worldborder, event.getSearchRadius(), event.getCanCreatePortal(), event.getCreationRadius()).map((p_258249_) -> {
+                    // CraftBukkit end
+                    BlockState blockstate = this.level().getBlockState(this.portalEntrancePos);
+                    Direction.Axis direction$axis;
+                    Vec3 vec3;
+                    if (blockstate.hasProperty(BlockStateProperties.HORIZONTAL_AXIS)) {
+                        direction$axis = blockstate.getValue(BlockStateProperties.HORIZONTAL_AXIS);
+                        BlockUtil.FoundRectangle blockutil$foundrectangle = BlockUtil.getLargestRectangleAround(
+                                this.portalEntrancePos,
+                                direction$axis,
+                                21,
+                                Direction.Axis.Y,
+                                21,
+                                p_284700_ -> this.level().getBlockState(p_284700_) == blockstate
+                        );
+                        vec3 = this.getRelativePortalPosition(direction$axis, blockutil$foundrectangle);
+                    } else {
+                        direction$axis = Direction.Axis.X;
+                        vec3 = new Vec3(0.5, 0.0, 0.0);
+                    }
+                    
+                    return PortalShape.createPortalInfo(worldserverFinal, p_258249_, direction$axis, vec3, this, this.getDeltaMovement(), this.getYRot(), this.getXRot(), event); // CraftBukkit
+                }).orElse(null);
             }
         } else {
             BlockPos blockpos;
@@ -2565,12 +_,14 @@
                 blockpos = p_19923_.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, p_19923_.getSharedSpawnPos());
             }
 
-            return new PortalInfo(
-                new Vec3((double)blockpos.getX() + 0.5, (double)blockpos.getY(), (double)blockpos.getZ() + 0.5),
-                this.getDeltaMovement(),
-                this.getYRot(),
-                this.getXRot()
-            );
+            // CraftBukkit start
+            org.bukkit.craftbukkit.v1_20_R3.event.CraftPortalEvent event = callPortalEvent(this, p_19923_, new Vec3(blockpos.getX() + 0.5D, blockpos.getY(), blockpos.getZ() + 0.5D), org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.END_PORTAL, 0, 0);
+            if (event == null) {
+                return null;
+            }
+
+            return new PortalInfo(new Vec3(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ()), this.getDeltaMovement(), this.getYRot(), this.getXRot(), ((org.bukkit.craftbukkit.v1_20_R3.CraftWorld) event.getTo().getWorld()).getHandle(), event);
+            // CraftBukkit end
         }
     }
 
@@ -2579,7 +_,25 @@
     }
 
     protected Optional<BlockUtil.FoundRectangle> getExitPortal(ServerLevel p_185935_, BlockPos p_185936_, boolean p_185937_, WorldBorder p_185938_) {
-        return p_185935_.getPortalForcer().findPortalAround(p_185936_, p_185937_, p_185938_);
+        return getExitPortal(p_185935_, p_185936_, p_185937_, p_185938_, p_185935_.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER? 16 : 128, false, 16);
+    }
+    // CraftBukkit start
+    protected org.bukkit.craftbukkit.v1_20_R3.event.CraftPortalEvent callPortalEvent(Entity entity, ServerLevel exitWorldServer, Vec3 exitPosition, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause, int searchRadius, int creationRadius) {
+        org.bukkit.entity.Entity bukkitEntity = entity.getBukkitEntity();
+        org.bukkit.Location enter = bukkitEntity.getLocation();
+        org.bukkit.Location exit = org.bukkit.craftbukkit.v1_20_R3.util.CraftLocation.toBukkit(exitPosition, exitWorldServer.getWorld());
+
+        org.bukkit.event.entity.EntityPortalEvent event = new org.bukkit.event.entity.EntityPortalEvent(bukkitEntity, enter, exit, searchRadius);
+        event.getEntity().getServer().getPluginManager().callEvent(event);
+        if (event.isCancelled() || event.getTo() == null || event.getTo().getWorld() == null || !entity.isAlive()) {
+            return null;
+        }
+        return new org.bukkit.craftbukkit.v1_20_R3.event.CraftPortalEvent(event);
+    }
+
+    protected Optional<BlockUtil.FoundRectangle> getExitPortal(ServerLevel p_185935_, BlockPos p_185936_, boolean p_185937_, WorldBorder p_185938_, int searchRadius, boolean canCreatePortal, int createRadius) {
+        return p_185935_.getPortalForcer().findPortalAround(p_185936_, p_185938_, searchRadius);
+        // CraftBukkit end
     }
 
     public boolean canChangeDimensions() {
@@ -2641,6 +_,7 @@
         return this.stringUUID;
     }
 
+    @Deprecated // Forge: Use FluidType sensitive version
     public boolean isPushedByFluid() {
         return true;
     }
@@ -2691,9 +_,20 @@
         }
     }
 
+    //Ketting start
+    public final java.util.concurrent.atomic.AtomicReference<org.bukkit.event.player.PlayerTeleportEvent.TeleportCause> ketting$teleportTo$cause = new java.util.concurrent.atomic.AtomicReference<>(org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN);
+    // CraftBukkit start
+    public boolean teleportTo(ServerLevel p_265257_, double p_265407_, double p_265727_, double p_265410_, Set<RelativeMovement> p_265083_, float p_265573_, float p_265094_, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause) {
+        ketting$teleportTo$cause.set(cause);
+        return this.teleportTo(p_265257_, p_265407_, p_265727_, p_265410_, p_265083_, p_265573_, p_265094_);
+    }
+    // CraftBukkit end
+    //Ketting end
+
     public boolean teleportTo(
         ServerLevel p_265257_, double p_265407_, double p_265727_, double p_265410_, Set<RelativeMovement> p_265083_, float p_265573_, float p_265094_
     ) {
+        ketting$teleportTo$cause.set(org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN);
         float f = Mth.clamp(p_265094_, -90.0F, 90.0F);
         if (p_265257_ == this.level()) {
             this.moveTo(p_265407_, p_265727_, p_265410_, p_265573_, f);
@@ -2710,7 +_,11 @@
             entity.moveTo(p_265407_, p_265727_, p_265410_, p_265573_, f);
             entity.setYHeadRot(p_265573_);
             this.setRemoved(Entity.RemovalReason.CHANGED_DIMENSION);
-            p_265257_.addDuringTeleport(entity);
+            // CraftBukkit start - Don't spawn the new entity if the current entity isn't spawned
+            if (inWorld) {
+                p_265257_.addDuringTeleport(entity);
+            }
+            // CraftBukkit end
         }
 
         return true;
@@ -2764,8 +_,10 @@
         EntityDimensions entitydimensions = this.dimensions;
         Pose pose = this.getPose();
         EntityDimensions entitydimensions1 = this.getDimensions(pose);
+        net.neoforged.neoforge.event.entity.EntityEvent.Size sizeEvent = net.neoforged.neoforge.event.EventHooks.getEntitySizeForge(this, pose, entitydimensions, entitydimensions1, this.getEyeHeight(pose, entitydimensions1));
+        entitydimensions1 = sizeEvent.getNewSize();
         this.dimensions = entitydimensions1;
-        this.eyeHeight = this.getEyeHeight(pose, entitydimensions1);
+        this.eyeHeight = sizeEvent.getNewEyeHeight();
         this.reapplyPosition();
         boolean flag = (double)entitydimensions1.width <= 4.0 && (double)entitydimensions1.height <= 4.0;
         if (!this.level().isClientSide
@@ -2778,9 +_,10 @@
             double d0 = (double)Math.max(0.0F, entitydimensions1.width - entitydimensions.width) + 1.0E-6;
             double d1 = (double)Math.max(0.0F, entitydimensions1.height - entitydimensions.height) + 1.0E-6;
             VoxelShape voxelshape = Shapes.create(AABB.ofSize(vec3, d0, d1, d0));
+            EntityDimensions finalEntitydimensions = entitydimensions1;
             this.level()
                 .findFreePosition(this, voxelshape, vec3, (double)entitydimensions1.width, (double)entitydimensions1.height, (double)entitydimensions1.width)
-                .ifPresent(p_185956_ -> this.setPos(p_185956_.add(0.0, (double)(-entitydimensions1.height) / 2.0, 0.0)));
+                .ifPresent(p_185956_ -> this.setPos(p_185956_.add(0.0, (double)(-finalEntitydimensions.height) / 2.0, 0.0)));
         }
     }
 
@@ -2810,7 +_,26 @@
     }
 
     public final void setBoundingBox(AABB p_20012_) {
-        this.bb = p_20012_;
+        // CraftBukkit start - block invalid bounding boxes
+        double minX = p_20012_.minX,
+                minY = p_20012_.minY,
+                minZ = p_20012_.minZ,
+                maxX = p_20012_.maxX,
+                maxY = p_20012_.maxY,
+                maxZ = p_20012_.maxZ;
+        double len = p_20012_.maxX - p_20012_.minX;
+        if (len < 0) maxX = minX;
+        if (len > 64) maxX = minX + 64.0;
+
+        len = p_20012_.maxY - p_20012_.minY;
+        if (len < 0) maxY = minY;
+        if (len > 64) maxY = minY + 64.0;
+
+        len = p_20012_.maxZ - p_20012_.minZ;
+        if (len < 0) maxZ = minZ;
+        if (len > 64) maxZ = minZ + 64.0;
+        this.bb = new AABB(minX, minY, minZ, maxX, maxY, maxZ);
+        // CraftBukkit end
     }
 
     protected float getEyeHeight(Pose p_19976_, EntityDimensions p_19977_) {
@@ -3076,9 +_,17 @@
         this.yRotO = this.getYRot();
     }
 
+    @Deprecated // Forge: Use no parameter version instead, only for vanilla Tags
     public boolean updateFluidHeightAndDoFluidPushing(TagKey<Fluid> p_204032_, double p_204033_) {
+        this.updateFluidHeightAndDoFluidPushing();
+        if(p_204032_ == FluidTags.WATER) return this.isInFluidType(net.neoforged.neoforge.common.NeoForgeMod.WATER_TYPE.value());
+        else if (p_204032_ == FluidTags.LAVA) return this.isInFluidType(net.neoforged.neoforge.common.NeoForgeMod.LAVA_TYPE.value());
+        else return false;
+    }
+
+    public void updateFluidHeightAndDoFluidPushing() {
         if (this.touchingUnloadedChunk()) {
-            return false;
+            return;
         } else {
             AABB aabb = this.getBoundingBox().deflate(0.001);
             int i = Mth.floor(aabb.minX);
@@ -3093,53 +_,73 @@
             Vec3 vec3 = Vec3.ZERO;
             int k1 = 0;
             BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
+            class InterimCalculation {
+                double fluidHeight = 0.0D;
+                Vec3 flowVector = Vec3.ZERO;
+                int blockCount = 0;
+            }
+            it.unimi.dsi.fastutil.objects.Object2ObjectMap<net.neoforged.neoforge.fluids.FluidType, InterimCalculation> interimCalcs = null;
 
             for(int l1 = i; l1 < j; ++l1) {
                 for(int i2 = k; i2 < l; ++i2) {
                     for(int j2 = i1; j2 < j1; ++j2) {
                         blockpos$mutableblockpos.set(l1, i2, j2);
                         FluidState fluidstate = this.level().getFluidState(blockpos$mutableblockpos);
-                        if (fluidstate.is(p_204032_)) {
+                        net.neoforged.neoforge.fluids.FluidType fluidType = fluidstate.getFluidType();
+                        if (!fluidType.isAir()) {
                             double d1 = (double)((float)i2 + fluidstate.getHeight(this.level(), blockpos$mutableblockpos));
                             if (d1 >= aabb.minY) {
                                 flag1 = true;
-                                d0 = Math.max(d1 - aabb.minY, d0);
-                                if (flag) {
+                                if (interimCalcs == null) {
+                                    interimCalcs = new it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap<>();
+                                }
+                                InterimCalculation interim = interimCalcs.computeIfAbsent(fluidType, t -> new InterimCalculation());
+                                interim.fluidHeight = Math.max(d1 - aabb.minY, interim.fluidHeight);
+                                if (this.isPushedByFluid(fluidType)) {
                                     Vec3 vec31 = fluidstate.getFlow(this.level(), blockpos$mutableblockpos);
-                                    if (d0 < 0.4) {
-                                        vec31 = vec31.scale(d0);
+                                    if (interim.fluidHeight < 0.4D) {
+                                        vec31 = vec31.scale(interim.fluidHeight);
                                     }
 
-                                    vec3 = vec3.add(vec31);
-                                    ++k1;
-                                }
+                                    interim.flowVector = interim.flowVector.add(vec31);
+                                    interim.blockCount++;
+                                }
+
+                                // CraftBukkit start - store last lava contact location
+                                if (fluidstate.is(FluidTags.LAVA)) {
+                                    this.lastLavaContact = blockpos$mutableblockpos.immutable();
+                                }
+                                // CraftBukkit end
                             }
                         }
                     }
                 }
             }
 
-            if (vec3.length() > 0.0) {
-                if (k1 > 0) {
-                    vec3 = vec3.scale(1.0 / (double)k1);
+            if(interimCalcs != null) {
+            interimCalcs.forEach((fluidType, interim) -> {
+            if (interim.flowVector.length() > 0.0D) {
+                if (interim.blockCount > 0) {
+                    interim.flowVector = interim.flowVector.scale(1.0D / (double)interim.blockCount);
                 }
 
                 if (!(this instanceof Player)) {
-                    vec3 = vec3.normalize();
+                    interim.flowVector = interim.flowVector.normalize();
                 }
 
                 Vec3 vec32 = this.getDeltaMovement();
-                vec3 = vec3.scale(p_204033_ * 1.0);
+                interim.flowVector = interim.flowVector.scale(this.getFluidMotionScale(fluidType));
                 double d2 = 0.003;
-                if (Math.abs(vec32.x) < 0.003 && Math.abs(vec32.z) < 0.003 && vec3.length() < 0.0045000000000000005) {
-                    vec3 = vec3.normalize().scale(0.0045000000000000005);
+                if (Math.abs(vec32.x) < 0.003D && Math.abs(vec32.z) < 0.003D && interim.flowVector.length() < 0.0045000000000000005D) {
+                    interim.flowVector = interim.flowVector.normalize().scale(0.0045000000000000005D);
                 }
 
-                this.setDeltaMovement(this.getDeltaMovement().add(vec3));
+                this.setDeltaMovement(this.getDeltaMovement().add(interim.flowVector));
             }
 
-            this.fluidHeight.put(p_204032_, d0);
-            return flag1;
+            this.setFluidTypeHeight(fluidType, interim.fluidHeight);
+            });
+            }
         }
     }
 
@@ -3152,7 +_,10 @@
         return !this.level().hasChunksAt(i, k, j, l);
     }
 
+    @Deprecated // Forge: Use getFluidTypeHeight instead
     public double getFluidHeight(TagKey<Fluid> p_204037_) {
+        if (p_204037_ == FluidTags.WATER) return getFluidTypeHeight(net.neoforged.neoforge.common.NeoForgeMod.WATER_TYPE.value());
+        else if (p_204037_ == FluidTags.LAVA) return getFluidTypeHeight(net.neoforged.neoforge.common.NeoForgeMod.LAVA_TYPE.value());
         return this.fluidHeight.getDouble(p_204037_);
     }
 
@@ -3289,6 +_,7 @@
 
             this.levelCallback.onMove();
         }
+        if (this.isAddedToWorld() && !this.level.isClientSide && !this.isRemoved()) this.level.getChunk((int) Math.floor(p_20344_) >> 4, (int) Math.floor(p_20346_) >> 4); // Forge - ensure target chunk is loaded.
     }
 
     public void checkDespawn() {
@@ -3360,10 +_,27 @@
         return false;
     }
 
+    /**
+     * Gets the value of the legacy {@link #maxUpStep} field. Only used by players when the modified value causes issues.
+     * @deprecated Use {@link net.neoforged.neoforge.common.extensions.IEntityExtension#getStepHeight()} to get the real step height value.
+     */
+    @Deprecated
     public float maxUpStep() {
         return this.maxUpStep;
     }
 
+    /**
+     * Changes the legacy {@link #maxUpStep} field. Only used by vanilla entities to improve maintainability.
+     * <p>
+     * For your own entities, you should change the default value of {@linkplain net.neoforged.neoforge.common.NeoForgeMod#STEP_HEIGHT NeoForgeMod#STEP_HEIGHT}
+     * during attribute creation.
+     * <p>
+     * For modifying the step height of other entities, you should use {@link net.minecraft.world.entity.ai.attributes.AttributeModifier AttributeModifiers} for
+     * {@link net.neoforged.neoforge.common.NeoForgeMod#STEP_HEIGHT NeoForgeMod#STEP_HEIGHT}.
+     *
+     * @deprecated Use attribute modifiers for the {@link net.neoforged.neoforge.common.NeoForgeMod#STEP_HEIGHT NeoForgeMod#STEP_HEIGHT} attribute.
+     */
+    @Deprecated
     public void setMaxUpStep(float p_275672_) {
         this.maxUpStep = p_275672_;
     }
@@ -3419,6 +_,126 @@
     public boolean mayInteract(Level p_146843_, BlockPos p_146844_) {
         return true;
     }
+
+    /* ================================== Forge Start =====================================*/
+
+    private boolean canUpdate = true;
+    @Override
+    public void canUpdate(boolean value) {
+        this.canUpdate = value;
+    }
+    @Override
+    public boolean canUpdate() {
+        return this.canUpdate;
+    }
+    @Nullable
+    private java.util.Collection<ItemEntity> captureDrops = null;
+    @Override
+    public java.util.Collection<ItemEntity> captureDrops() {
+        return captureDrops;
+    }
+    @Override
+    public java.util.Collection<ItemEntity> captureDrops(@Nullable java.util.Collection<ItemEntity> value) {
+        java.util.Collection<ItemEntity> ret = captureDrops;
+        this.captureDrops = value;
+        return ret;
+    }
+    private CompoundTag persistentData;
+    @Override
+    public CompoundTag getPersistentData() {
+        if (persistentData == null)
+            persistentData = new CompoundTag();
+        return persistentData;
+    }
+    @Override
+    public boolean canTrample(BlockState state, BlockPos pos, float fallDistance) {
+        return level.random.nextFloat() < fallDistance - 0.5F
+             && this instanceof LivingEntity
+             && (this instanceof Player || net.neoforged.neoforge.event.EventHooks.getMobGriefingEvent(level, this))
+             && this.getBbWidth() * this.getBbWidth() * this.getBbHeight() > 0.512F;
+    }
+
+    /**
+     * Internal use for keeping track of entities that are tracked by a world, to
+     * allow guarantees that entity position changes will force a chunk load, avoiding
+     * potential issues with entity desyncing and bad chunk data.
+     */
+    private boolean isAddedToWorld;
+
+    @Override
+    public final boolean isAddedToWorld() { return this.isAddedToWorld; }
+
+    @Override
+    public void onAddedToWorld() { this.isAddedToWorld = true; }
+
+    @Override
+    public void onRemovedFromWorld() { this.isAddedToWorld = false; }
+
+    @Override
+    public void revive() {
+        this.unsetRemoved();
+    }
+
+    // no AT because of overrides
+    /**
+     * Accessor method for {@link #getEyeHeight(Pose, EntityDimensions)}
+     */
+    public float getEyeHeightAccess(Pose pose, EntityDimensions size) {
+        return this.getEyeHeight(pose, size);
+    }
+
+    protected Object2DoubleMap<net.neoforged.neoforge.fluids.FluidType> forgeFluidTypeHeight = new Object2DoubleArrayMap<>(net.neoforged.neoforge.fluids.FluidType.SIZE.get());
+    private net.neoforged.neoforge.fluids.FluidType forgeFluidTypeOnEyes = net.neoforged.neoforge.common.NeoForgeMod.EMPTY_TYPE.value();
+    protected final void setFluidTypeHeight(net.neoforged.neoforge.fluids.FluidType type, double height) {
+        this.forgeFluidTypeHeight.put(type, height);
+    }
+    @Override
+    public final double getFluidTypeHeight(net.neoforged.neoforge.fluids.FluidType type) {
+        return this.forgeFluidTypeHeight.getDouble(type);
+    }
+    @Override
+    public final boolean isInFluidType(java.util.function.BiPredicate<net.neoforged.neoforge.fluids.FluidType, Double> predicate, boolean forAllTypes) {
+        if (this.forgeFluidTypeHeight.isEmpty()) {
+            return false;
+        }
+        return forAllTypes ? this.forgeFluidTypeHeight.object2DoubleEntrySet().stream().allMatch(e -> predicate.test(e.getKey(), e.getDoubleValue()))
+                  : this.forgeFluidTypeHeight.object2DoubleEntrySet().stream().anyMatch(e -> predicate.test(e.getKey(), e.getDoubleValue()));
+    }
+    @Override
+    public final boolean isInFluidType() {
+        return this.forgeFluidTypeHeight.size() > 0;
+    }
+  @Override
+  public final net.neoforged.neoforge.fluids.FluidType getEyeInFluidType() {
+        return forgeFluidTypeOnEyes;
+    }
+    @Override
+    public net.neoforged.neoforge.fluids.FluidType getMaxHeightFluidType() {
+        if (this.forgeFluidTypeHeight.isEmpty()) {
+            return net.neoforged.neoforge.common.NeoForgeMod.EMPTY_TYPE.value();
+        }
+        return this.forgeFluidTypeHeight.object2DoubleEntrySet().stream().max(java.util.Comparator.comparingDouble(Object2DoubleMap.Entry::getDoubleValue)).map(Object2DoubleMap.Entry::getKey).orElseGet(net.neoforged.neoforge.common.NeoForgeMod.EMPTY_TYPE::value);
+    }
+
+    @Override
+    @Nullable
+    public final <T> T setData(net.neoforged.neoforge.attachment.AttachmentType<T> type, T data) {
+        // Entities are always saved, no setChanged() call is necessary.
+        return super.setData(type, data);
+    }
+
+    @Nullable
+    public final <T, C> T getCapability(net.neoforged.neoforge.capabilities.EntityCapability<T, C> capability, @org.jetbrains.annotations.UnknownNullability C context) {
+        return capability.getCapability(this, context);
+    }
+
+    @Nullable
+    public final <T> T getCapability(net.neoforged.neoforge.capabilities.EntityCapability<T, Void> capability) {
+        return capability.getCapability(this, null);
+    }
+
+    /* ================================== Forge End =====================================*/
+
 
     public Level level() {
         return this.level;
